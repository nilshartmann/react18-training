<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>React Training</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"
    />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/reset.css" />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/reveal.css" />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/theme/solarized.css" />

    <!-- Theme used for syntax hislides/ghlighted code -->
    <link rel="stylesheet" href="slides/revealjs/highlight-js-github-theme.css" />
    <link rel="stylesheet" href="slides/revealjs/styles.css" />
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-state="title">
          <h2 class="title" style="font-size: 7rem">
            <b>React &amp; TypeScript Workshop</b>
          </h2>

          <h4>
            <span class="transparent-bg">
              <a href="https://nilshartmann.net" target="_blank">Nils Hartmann</a>
              |
              <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
            </span>
          </h4>

          <p style="margin-top: 4rem"></p>
          <div>
            <h3><span class="transparent-bg">Slides</span></h3>
            <p>
              <span class="transparent-bg">Lokal: 2022-10-10-react-typescript-graphql.html</span>
            </p>
            <p>
              <span class="transparent-bg"
                >Remote:
                <a
                  href="https://nilshartmann.github.io/react18-training/2022-10-10-react-typescript-graphql.html"
                  >https://nilshartmann.github.io/react18-training/2022-10-10-react-typescript-graphql.html</a
                ></span
              >
            </p>
          </div>
        </section>
        <section>
          <h2>Nils Hartmann</h2>
          <p>
            <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a>
            /
            <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
          <p>
            <em>Freiberuflicher Software-Entwickler, Berater und Trainer aus Hamburg</em>
          </p>

          <div style="display: flex; justify-content: center">
            <div>
              <p>Java</p>
              <p>JavaScript, TypeScript</p>
              <p>React</p>
              <p>Single-Page-Applications</p>
              <p>GraphQL</p>
              <p style="margin-top: 20px">
                <a href="https://nilshartmann.net/workshops">Schulungen und Workshops</a>
              </p>
            </div>
            <div style="margin-left: 15px">
              <a href="https://reactbuch.de"
                ><img
                  style="max-height: 450px"
                  src="slides/images/react-buch-v2.jpg"
                /><br />https://reactbuch.de</a
              >
              <br />
            </div>
          </div>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h2>Agenda</h2>
          <ul class="xx-list">
            <li>
              <a href="#/t-test">Testen mit Jest</a>
            </li>
            <li>
              <a href="#/t-apollo-react">Apollo Client</a>
            </li>
            <li>
              <a href="#/t-context">Context API</a>
            </li>
            <li>
              <a href="#/t-apollo-react-deep-dive">Apollo Deep Dive</a>
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->

        <section id="t-test">
          <h2>Testen von React Anwendungen</h2>
        </section>
        <section data-markdown>
          <textarea data-template>
### Vorbereitung
* Wir machen alle Übungen im `blog-example/workspace-typescript`-Verzeichnis.

* Zunächst das "Backend" starten, in `blog-example/backend-rest`:
  * ```
  npm install
  npm start
  ```
* In `blog-example/workspace-typescript` enthalten sind zwei _JavaScript_-Dateien. Diese Dateien bitte **löschen**!
* Dann kopierst Du aus dem Verzeichnis <code>blog-example/steps/5-typescript/src</code> die beiden Dateien:
  * `PostEditor.tsx`
  * `PostList.tsx`
  * in den `src`-Ordner in deinem Workspace (`workspace-typescript/src`)
* Dann bitte `npm install` ausführen und die Anwendung starten. In `blog-example/workspace-typescript`:
  * ```
    npm install
    npm start
    ```  
* Einmal die Anwendung im Browser öffnen, um zu sehen, ob's geht: http://localhost:3000    
* Die gestartete Anwendung kannst Du verwenden, um dir den PostEditor anzusehen, für den wir Test schreiben werden    
          </textarea>
        </section>

        <section data-transition="slide none">
          <h2>Was testen wir?</h2>
          <ul>
            <li><b>UI-unabhängige Logik</b> (zum Beispiel Backend Calls, Berechnungen etc.)</li>
            <li>
              <b>Rendering</b> (Ist die Liste der Blog Posts korrekt? Sieht das Markup aus, wie wir
              uns das vorstellen?) und <b>Interaktionen</b> (funktionieren die Event Handler, die
              Callback-Funktionen, der Programmfluß etc.?)
            </li>
            <li>
              <b>Verhalten im Browser</b> (z.B. korrekte, pixelgenaue Darstellung,
              Browser-spezifisches JavaScript, Arbeiten mit Browser-Technologie wie Titelzeile,
              Session Storage, Scrollbars etc)
            </li>
          </ul>
        </section>

        <section>
          <h1>Jest</h1>
          <p>
            <em
              >"Delightful JavaScript Testing" (
              <a href="https://jestjs.io/" target="_blank">https://jestjs.io/</a>)</em
            >
          </p>
          <p>Vollständige Testlösung für React (und andere):</p>
          <ul>
            <li>API vergleichbar mit <a href="https://jasmine.github.io/">Jasmine</a></li>
            <li>Test Runner</li>
            <li>Specs/Assertions, Mocks</li>
            <li>Code Coverage</li>
          </ul>
        </section>
        <section>
          <h4>Jest</h4>
          <h3>Beispiel: Ein einfacher Testfall</h3>
          <pre><code class="javascript"  >// sum.js (or sum.ts)
export const sum = (a,b) => a+b;
        </code></pre>
          <pre><code class="javascript"  >// sum.test.js
import {sum} from '../sum.js';

test('sum of 2 and 2 is 4', () => {
  expect(sum(2, 2)).toBe(4);
});

test('sum of 2 and 2 is not 3', () => {
  expect(sum(2, 2)).not.toBe(3);
});
            </code></pre>
        </section>
        <section>
          <h4>Jest</h4>
          <h2>Testcases</h2>
          <p>
            <code>test</code> oder
            <code>it</code>
          </p>
          <pre><code>test('it should work', () => {
  expect(...).toBe(...);
});</code></pre>
          <pre><code>it('it should also work', () => {
  expect(...).toBe(...);
});</code></pre>
        </section>

        <section>
          <h4>Jest</h4>
          <h2>"Expectations" und "Matchers"</h2>
          <div>
            <p>
              <code>expect()</code> liefert ein <em>Expectation</em> Objekt zurück, das verschiede
              <em>Matcher</em> Funktionen bereitstellt:
            </p>
            <pre><code>expect(actual).toXyz(expected);
// for example:
expect("Hello Jest").toBe("Hello Jest"); // => ok
        </code></pre>
          </div>
          <div>
            <p>Beispiele für Matchers</p>

            <pre><code>// Compare identity
expect(actual).toBe(expected);
// Compare value:
expect(actual).toEqual(expected);
// true / false / null:
expect(actual).toBeTruthy();
expect(actual).toBeFalsy();
expect(actual).toBeNull();
// Length (Array oder String)
expect(actual).toHaveLength(123);
        </code></pre>
          </div>
          <p>
            <a href="https://jestjs.io/docs/en/expect">https://jestjs.io/docs/en/expect</a>
          </p>
        </section>

        <section>
          <h4>Jest</h4>
          <h2>Mock Funktionen</h2>
          <ul>
            <li>
              <code>jest.fn()</code> erzeugt eine Mock-Funktion
              <pre><code>// Gibt undefined zurück, wenn die Mock-Funktion ausgeführt wird
const aMockFn = jest.fn();

const x = aMockFn("hello", "world"); // => undefined
expect(x).toBeUndefined();
              </code></pre>
            </li>
            <li>
              Mit <code>toHaveBeenCalled</code>-Matcher-Funktionen kann geprüft werden, ob der Mock
              aufgerufen wurde, wie häufig und mit welchen Parametern:
              <pre><code>
expect(aMockFn).toHaveBeenCalled());  // Mock wurde aufgerufen (Parameter werden ignoriert)
expect(aMockFn).toHaveBeenCalledWith("hello", "world")); // Mock wurde mit 'huhu' aufgerufen
expect(aMockFn).toHaveBeenCalledTimes(1)); // Mock wurde genau einmal aufgerufen

// Übergebene Paramter stehen über .mock.calls:
expect(aMockFn.mock.calls[0][0]).toBe("hello");
expect(aMockFn.mock.calls[0][1]).toBe("world");
                      </code></pre>
            </li>
            <li>
              Implementierung der Mock-Funktion kann als Parameter übergeben:
              <pre><code>
        const aMockFn = jest.fn( param => `Hello, ${param}` );
        
        console.log(aMockFn('World'));
        // => Hello, World
                  </code></pre>
            </li>
          </ul>
        </section>

        <section data-markdown>
          <textarea data-template>
### Übung: Hello Jest!

* Im Workspace-Verzeichnis `blog-example/workspace-typescript` findest Du eine Datei `format-persons.ts`, die eine einzige Funktion enthält.
* Schreibe für diese Funktion einen Test in `workspace-typescript/__tests__/format-persons.test.ts`
* Du kannst den Test mit `npm test -- format-person` ausführen
* Hinweise dazu findest Du in `format-persons.test.ts`
* Wenn Du fertig bist, bitte virtuell die Hand haben 🙋🏻‍♀️  

        </textarea
          >
        </section>

        <section>
          <h3>Testen von React Komponenten</h3>
        </section>

        <section>
          <h3>react-testing-library</h3>
          <p>
            <em
              >"Simple and complete React DOM testing utilities that encourage good testing
              practices."
            </em>
          </p>

          <p>
            <a href="https://github.com/testing-library/react-testing-library" target="_blank"
              >https://github.com/testing-library/react-testing-library</a
            >)
          </p>
          <p>
            Philosophie: Tests werden aus User-Perspektive geschrieben. Das bedeutet, um die zu
            testenden Elemente zu finden, suchst Du nach Eigenschaften, nach denen auch ein User
            suchen würde (z.B. Labels, Placeholder etc.)
          </p>
          <p>👉 <code>workspace-typescript</code></p>
        </section>
        <section>
          <h3>react-testing-library</h3>
          <p>Example</p>
          <pre><code class="javascript"  >
            import { render, screen } from "@testing-library/react";
            import userEvent from "@testing-library/user-event";

            it("invokes callback on button click", () => {
              const onAddPostFn = jest.fn();
            
              // Render
              render(&lt;PostList onAddPost={onAddPostFn} posts={mockPosts} />);
            
              // search the button
              const buttonElement = screen.getByRole("button", { name: "Add Post" });

              // "click" the button
              userEvent.click(buttonElement);
            
              // make sure it has been invoked
              expect(onAddPostFn).toHaveBeenCalled();
            });

            </code></pre>
        </section>

        <section>
          <h3>React Testing Library im Detail</h3>
        </section>

        <section>
          <h3>Die render-Funktion</h3>
          <ul>
            <li>
              Die render-Function aus der react-testing-library wird im Test verwendet, um eine
              React Komponente (ohne Browser) zu rendern
            </li>
            <li>Genauso wie in der Anwendungen können Properties angegeben werden</li>
            <li>
              <pre><code class="javascript"  >
import { render } from "@testing-library/react";
  
// Render a single component
render(&lt;PostList onAddPost={onAddPostFn} posts={mockPosts} />);
            </code></pre>
            </li>
            <li>
              Dran denken, ggf. Contexte ebenfalls zu erzeugen, falls diese benötigt werden (Router,
              Redux, GraphQL etc)!
            </li>
            <li>
              <pre><code class="javascript"  >

// Render with surrounding Redux Provider (or Router, your own Context etc.)
render(
  &lt;Provider>
    &lt;PostList onAddPost={onAddPostFn} posts={mockPosts} />
  &lt;/Provider>
);
            </code></pre>
            </li>
            <li>
              Mock Provider:
              <ul>
                <li>
                  <a href="https://reactrouter.com/en/main/router-components/memory-router"
                    >Memory Router</a
                  >
                </li>
                <li>
                  <a
                    href="https://www.apollographql.com/docs/react/development-testing/testing/#the-mockedprovider-component"
                    >Apollo MockedProvider</a
                  >
                </li>
              </ul>
            </li>
          </ul>
        </section>

        <!-- ######################################################################################### ########################## -->

        <section>
          <h3>"Snapshot Testing" mit Jest</h3>
          <p>
            <code>expect(obj).toMatchSnapshot()</code> vergleicht ein erzeugtes JSON-Objekt mit
            einem gespeicherten JSON-Objekt aus einer Datei:
          </p>
          <ul>
            <li>
              Bei der <b>ersten</b> Ausführung: Snapshot-Datei wird angelegt (
              <a href="slides/images/jest-snapshot-file.png" target="_blank">Beispiel</a>)
              <ul>
                <li>Die Snapshot-Datei wird nun in Git eingecheckt</li>
              </ul>
            </li>
            <li>
              In den <b>folgenden</b> Test Ausführungen: ein neuer Snapshot wird jeweils erzeugt und
              mit dem <b>gespeicherten</b> Snapshot verglichen
            </li>
            <li>
              Wenn die Snapshots nicht identisch sind:
              <ul>
                <li>
                  Fehler mit Unterschieden (<a
                    href="slides/images/jest-snapshot-diff.png"
                    target="_blank"
                    >Beispiel</a
                  >)
                </li>
                <li>
                  Im "watch mode" von Jest kann der Snapshot aktualisiert werden
                  <img src="slides/images/jest-snapshot-update.png" />
                </li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h3>Snapshot Tests mit React</h3>
          <pre><code class="javascript"  >import renderer from 'react-test-renderer';
        
test('it should render correctly', () => {

    const mockPosts = [ /* ... */ ];

    const result = render(<PostList posts={mockPosts} onAddPost={jest.fn()} />);
    expect(result.asFragment()).toMatchSnapshot();
});
            </code></pre>
        </section>

        <!-- ######################### ########################### #################################################### -->
        <section>
          <h3>query Funktionen</h3>
          <p>
            Um die gerenderten HTML-Elemente aus deiner Komponente zu überprüfen und mit ihnen zu
            interagieren, musst Du sie ersteinmal finden 🤓
          </p>
          <p>
            Auf dem globalen <b>screen</b> Objekt der Testing-Lib sind verschiedene Funktionen
            definiert, mit denen Du nach Elementen suchen kannst
          </p>
          <p>
            Die query-Funktionen haben unterschiedliche <b>Suffixe</b>, die beschreiben,
            <b>nach welchem Kriterium</b> Du suchst (nach Label, nach aria-role, ...)
          </p>
          <p>
            Die Funktionen haben außerdem jeweils einen <b>Präfix</b> (getBy, queryBy etc) der
            beschreibt, die Art des Rückgabewerts der jeweilgen Funktion (z.B. ob sie einen Error
            wirft oder null zurückgibt, wenn das angefragte Element nicht gefunden wurde)
          </p>
          <p>
            Mehr zu den query-Funktionen:
            <a
              target="_blank"
              href="https://testing-library.com/docs/react-testing-library/cheatsheet#queries"
              >React Testing Library Cheatsheet</a
            >
          </p>

          <pre><code class="javascript">
  // BEISPIELE: 

  // suche nach einem Button (Annahme: es gibt GENAU EINEN, ansonsten schlägt der Test fehl)
  const buttonElement = screen.getByRole("button", { name: "Add Post" });

  // suche nach einem Button (gibt null oder EINEN Button, wirft ansonst einen Fehler)
  const buttonElement = screen.queryByRole("button", { name: "Add Post" });

  // suche nach einem Button (gibt alle gefunden zurück oder ein leeres Array)  
  const buttonElement = screen.queryAllByRole("button", { name: "Add Post" });
</code></pre>
        </section>

        <section>
          <h3>Überprüfen von Elementen</h3>
          <p>
            Wenn Du dein gesuchtes Elemente gefunden hast, kannst Du es überprüfen, ob es deinen
            Erwartungen entspricht (korrekte Attribute gesetzt etc.)
          </p>
          <p>
            Die Bibliothek
            <a href="https://github.com/testing-library/jest-dom" target="_blank">jest-dom</a> fügt
            dazu DOM-spezifiche Matcher für Jest hinzu.
          </p>

          <pre><code class="javascript">
  import { screen } from "@testing-library/react";

  const buttonElement = screen.queryByRole("button", { name: "Add Post" });

  // stellt sicher, dass das Element im DOM vorhanden ist (getBy-Query würde hier vielleicht mehr Sinn machen)
  expect(buttonElement).toBeInTheDocument();

  // sicherstellen, dass ein Eingabefeld einen erwarteten Wert hat
  expect(titleInput).toHaveValue("Moin moin");

  // sicherstellen, dass ein Button disabled ist
  expect(okButton).toBeDisabled();
</code></pre>
          <p>Alle Matcher sind auf der oben verlinkten GitHub Seite dokumentiert</p>
        </section>
        <section>
          <h3>Interaktionen</h3>
          <p>
            Du kannst mit den Elementen interagieren, in dem Du ihnen Events sendest, genau wie es
            ein Browser tun würde
          </p>
          <p>
            Es gibt eine weitere Bibliothek,
            <a href="https://github.com/testing-library/user-event" target="_blank"> user-event</a>,
            die dir dabei hilft, die Events zu erzeugen.
          </p>

          <pre><code class="javascript">
            import userEvent from "@testing-library/user-event";
            // Simuliert die Eingabe in ein Textfeld
            userEvent.type(titleInput, "New Title");

            // Simuliert den Klick auf einen Button
            userEvent.click(clearButton);
          </code></pre>
          <p>Alle Events sind auf der GitHub Seite beschrieben (Link oben)</p>

          <p>
            Vor dem Versenden eines Events musst Du <b>nicht</b> überprüfen, ob das Element, dem Du
            das Event senden willst, vorhanden ist. Die Bibliothek gibt eine sehr sprechende
            Fehlermeldung aus, wenn das Element nicht vorhanden ist
          </p>
        </section>

        <section data-markdown>
          <textarea data-template>
## Der Testing Playground

* https://testing-playground.com/
* Hier kann man HTML-Code reinkopieren, mit dem man dann Query-Funktionen ausprobieren kann
* Dazu gibt es auch eine Browser-Erweiterung für [Chrome](https://chrome.google.com/webstore/detail/testing-playground/hejbmebodbijjdhflfknehhcgaklhano)
* Mit `screen.logTestingPlaygroundURL()` kann man eine URL ausgeben lassen, die den im Test gerenderten HTML-Code direkt im Playground öffnet
          </textarea>
        </section>

        <section>
          <h2>Übung: Ein Test für den PostEditor</h2>
        </section>

        <section>
          <h2>Übung: Tests für den PostEditor</h2>
          <p>Erinnerung: Wir arbeiten in <code>blog-example/workspace-typescript</code></p>
          <p>Schritte:</p>
          <ol>
            <li class="fragment">
              Starte in <code>blog-example/workspace-typescript</code>:
              <code>npm test -- PostEditor</code> (der Prozess läuft "ewig")
            </li>
            <li class="fragment">
              Es sollte einen fehlerhaften Test geben:
              <b><code>PostEditor.test.tsx</code></b
              >.
            </li>
            <li class="fragment">Warum? Weil die Datei noch leer ist 😬!</li>
            <li class="fragment">
              Implementiere Tests für die PostEditor-Komponente. In der Datei<b
                ><code>PostEditor.test.tsx</code></b
              >
              findest Du Vorschläge.
            </li>
          </ol>
          <p class="fragment">
            Hinweis: wenn Du die Datei speicherst, werden die Tests automatisch neu ausgeführt
            (solange Du
            <code>npm test</code> noch laufen hast), ansonsten kannst Du "a" auf der Kommandozeile
            drücken, zum erneuten Ausführen der Tests.
          </p>
          <p class="fragment">Mögliche Lösungen in <code>steps/6-test</code></p>
          <p class="fragment">Wenn Du fertig bist, bitte "Hand heben" 🙋‍♀️</p>
        </section>

        <section>
          <h3>Testen von fetch-Aufrufen</h3>
          <p>Herausforderungen:</p>
          <ul>
            <li>Asynchroner Code (nicht beschränkt auf fetch)</li>
            <li>Server Zugriffe/Server Mocks</li>
          </ul>
        </section>
        <section>
          <h3>Behandlung von asynchronem code</h3>
        </section>

        <section>
          <h3>Testen von asynchronem Code</h3>
          <p>
            Beispiel: Die <b>App</b> Komponente lädt Daten, <em>erst dann</em> stellt sie die
            PostList dar. Das Laden der Posts ist asynchron.
          </p>

          <pre><code class="javascript">
            it("should render posts read from backend", () => {
              render(&lt;App />);
            
              // Annahme: es gibt einen Artikel mit dem Title "Learning React"
              const articleOne = screen.findByRole("heading", { name: "Learning React" });

              expect(articleOne).toBeInTheDocument(); // THIS WON'T WORK!
            });
          </code></pre>
          <p>
            Wir können einen Test als async-funktion schreiben und darin mit <b>await</b> auf ein
            Element warten
          </p>
          <pre><code class="javascript">
            // Test-Funktion als async-Funktion (beachte 'async'):
            it("should render posts read from backend", async () => {
              render(&lt;App />);
            
              // Beachte await hier:
              const articleOne = await screen.findByRole("heading", { name: "Learning React" });

              expect(articleOne).toBeInTheDocument(); // YIPPIE, WORKS
            });
          </code></pre>
          <p>
            Achtung! Ihr müsst <code>find</code> Query-Funktionen verwenden, da die
            <code>get</code>-Funktionen davon ausgehen, dass ein Element bereits vorhanden ist, und
            nicht noch darauf warten.
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Testen von fetch</h3>
          <p>Wie gesehen, können wir asynchronen Code testen</p>
          <p>Wollen wir fetch-Aufrufe in unserem Code haben, den wir testen?</p>
          <p>
            Möglicherweise nicht, weil wir bei echten fetch-Aufrufen auch einen echten, laufenden
            und funktionierenden Server im Test bräuchten
          </p>
          <p>Stattdessen wollen wir das "echte" fetch mocken</p>
        </section>

        <section>
          <h3>Fetch mocken, Ansatz #1</h3>
          <p>Wir können <b>komplette Module</b> in Jest mocken</p>
          <p>Wir könnten unseren fetch-Code in ein eigenes Modul schieben und das dann mocken</p>

          <pre><code class="javascript">
            // api.ts (fetch vereinfacht!)
            export function readPosts() {
              return fetch("http://localhost:7000/posts").then(response => response.json());
            }
          </code></pre>

          <pre><code class="javascript">
            // App.tsx:

            import { readPosts } from "./api";
            function App() {
              // ...
              React.useEffect(() => {
                // Verwenden von readPosts hier:
                readPosts()
                  .then(json => {
                    setLoading(false);
                    setPosts(json);
                  })
                  .catch(err => console.error("Loading data failed: " + err));
              }, []);
            }
          </code></pre>
        </section>
        <section>
          <h3>Mocken von Modulen in Jest</h3>
          <p>Es gibt mehrere Varianten. Das hier die einfachste(?)</p>

          <pre><code class="javascript">
            // App.test.tsx

            const mockPosts = [
              { id: "1", title: "One Fetch Mock", body: "Lorem ipsum" },
              { id: "2", title: "Second Post Fetch Mock", body: "Some more content" }
            ];

            jest.mock("../api", () => ({
              readPosts: () => Promise.resolve(mockPosts)
            }));

            it("should render posts read from backend", async () => {
              render(&lt;App />);
            
              // Hier immer noch asnychroner Code (deswegen await), aber:
              // kein laufender Server mehr benötigt
              const articleOne = await screen.findByRole("heading", { name: "One" });
              expect(articleOne).toBeInTheDocument();

              expect(screen.getByText("Second Post")).toBeInTheDocument();
            });
          </code></pre>
          <p>
            Beispiel:
            <code
              >blog-example/steps/6a-testing-with-api-module/src/__tests__/App_module_mock.test.tsx</code
            >
          </p>
        </section>
        <section>
          <h3>Ansatz #2: fetch API mocken</h3>
          <p>Es gibt mehrere Bibliothken mit fetch-Mocks</p>
          <p>
            Für mich funktioniert
            <a href="https://www.npmjs.com/package/jest-fetch-mock" target="_blank"
              >jest-fetch-mock</a
            >
            am Besten
          </p>

          <pre><code class="javascript">
            // App.test.tsx
            it("should render posts read from backend", async () => {
              // setzen des Ergebnisses, das der nächste fetch-Aufruf zurückliefern soll
              fetchMock.mockResponse(JSON.stringify(mockPosts));

              render(&lt;App />);
            
              // Immer noch asynchroner Code, aber kein "echter" fetch-Aufruf mehr,
              // zurückgegeben wird das oben angegebene Ergebnis
              const articleOne = await screen.findByRole("heading", { name: "One Fetch Mock" });

              expect(articleOne).toBeInTheDocument();
            });

          </code></pre>
          <p>
            Beispiel:
            <code
              >blog-example/steps/6a-testing-with-api-module/src/__tests__/App_jest_mock.test.tsx</code
            >
          </p>
        </section>

        <section data-markdown>
          <textarea data-template>
### jest-fetch-mock

* `fetchMock.mockResponse`: Ersetzt *alle* Aufrufe mit dem übergebenen Ergebnis
* `fetchMock.mockResponseOnce`: Ersetzt nur den nächsten Aufruf mit dem übergebenen Ergebnis
* `fetchMock.mockResponses`: Ersetzt die nächsten X Aufrufe mit den übergebenen Ergebnissen
* Alle Funktionen haben dieselbe Signatur:
  * Entweder ihr setzt direkt das Ergebnis, das zurückgeliefert werden soll
  * Oder ihr gebt eine Callback-Funktion an, die ein `Promise` mit der gewünschten Ergebnis zurückliefert
* Wenn ihr das Ergebnis direkt setzt, könnt ihr zwei Parameter übergeben:
  1. Den Body, der zurückgeliefert werden soll Achtung! String kein Objekt! (ggf.`JSON.stringify()` verwenden)
  2. Ein Objekt mit init-Parametern, mit dem ihr z.B. den Status setzen könnt
  * siehe dazu [API Dokumentation der Response Funktion](https://developer.mozilla.org/en-US/docs/Web/API/Response/Response)
* ```
  const mockPosts = [ { title: "Hello", body: "World"} ];
  // liefert HTTP 200 OK zurück für alle folgenden fetch-Aufrufe zurück:
  fetchMock.mockResponse(JSON.stringify(mockPosts));
  ```
* ```
const mockResponse = { id: "100", title: "Hello", body: "World", createdAt: "2022-09-06"};
// liefert HTTP 201 CREATED für den nächsten fetch-Aufrufe zurück:
fetchMock.mockResponse(JSON.stringify(mockResponse), { status: 201 });
```


          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Ansatz #3: Mock Service Worker (MSW)</h3>

          <p><a href="https://github.com/mswjs/msw" target="_blank">MSW</a></p>
          <p>
            MSW mockt echte Server-Aufrufe mit einem
            <a href="https://developer.mozilla.org/de/docs/Web/API/Service_Worker_API"
              >Service Worker</a
            >
          </p>
          <p>
            fetch-Aufrufe werden "richtig" ausgeführt, aber beantwortet von dem Service Worker Mock
          </p>

          <pre><code class="javascript">
            // PostList.test.js
            import { rest } from 'msw'
            import { setupServer } from 'msw/node'
            
            const server = setupServer(
              rest.get('/posts', (req, res, ctx) => {
                return res(ctx.json( mockPosts ))
              }),
            )

            test("it should render blog list", async () => {
              render(&lt;PostList />);
              // ...
            })
          </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
### Übung: Ein "Integrationstest" für die Blog-Anwendung

* Die `App.test.txt` ist auch noch leer 😢
* Schreibe einen Test dafür, der einmal die Anwendung "durchklickt". Stelle sicher:
  * Die Postlist-Komponente wird initial mit einer Menge von mockPosts gerendert
  * Der `Add Post`-Button funktioniert und öffnet den PostEditor.
  * Das Speichern funktioniert
  * Nach dem Speichern wird wieder die PostList angzeigt und der neue Post wird sichtbar
* Verwende zum Mocken der Request die `jest-fetch-mock`-Bibliothek
* In `App.test.tsx` findest Du weitere Hilfe.
* Ausführen des Tests: `npm test -- App`
* Achtung: Es gibt einen [Bug in der React Testing Library](https://github.com/testing-library/react-testing-library/issues/1051), der zu folgender Warnung auf der Konsole führt:
  * Diese **act**-Warnung bitte ignorieren:
  * ```
    console.error
    Warning: An update to App inside a test was not wrapped in act(...).
    
    When testing, code that causes React state updates should be wrapped into act(...):
    
    act(() => {
      /* fire events that update state */
    });
    /* assert on the output */
    ```            
          </textarea>
        </section>

        <section>
          <h2>Browser Tests</h2>
          <p>Häufig eingesetzt:</p>
          <ul>
            <li>
              <a href="https://www.selenium.dev/">Selenium - The "classic"</a>
            </li>
            <li><a href="https://www.cypress.io/" target="_blank">Cypress</a></li>
            <li>
              <a href="https://devexpress.github.io/testcafe/" target="_blank">TestCafe</a> (mit
              Support für sehr viele Browser, u.a. auch den Cloud-Service
              <a href="https://www.browserstack.com/" target="_blank">BrowserStack</a>)
            </li>
            <li>
              <a href="https://playwright.dev/">Playwright</a> von Microsoft. Noch relativ neu,
              Hype-Kurve zeigt gerade steil nach oben.
            </li>

            <li>
              In TestCafe und Cypress werden die Tests in JavaScript/TypeScript geschrieben,
              Selenium und Playwright gibt's für mehrere Sprachen
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->

        <!-- ########################## GRAPHQL ######################################### -->
        <section id="t-apollo-react">
          <h1>GraphQL</h1>
          <h2>Clients mit Apollo React</h2>
        </section>
        <section data-markdown>
          <textarea data-template>
### Vorbereitung
* Bitte das Repository klonen: `git clone https://github.com/nilshartmann/react18-training`
* Das GraphQL Backend starten:
* ```bash
  cd blog-example/backend-graphql
  npm install 
  npm start
  ```
* GraphQL Explorer sollte auf [http://localhost:4000](http://localhost:4000) laufen
* Wir arbeiten dann im Verzeichnis `blog-example/workspace-graphql`
* Dort die Anwendung starten:
* ```bash
  cd blog-example/workspace-graphql
  npm install 
  npm start
  ```
* Anwendung sollte jetzt auf [http://localhost:3000](http://localhost:3000) laufen
        
  </textarea
          >
        </section>
        <section>
          <h3>Apollo Client</h3>
          <p>
            <a href="https://www.apollographql.com/docs/react/"
              >https://www.apollographql.com/docs/react/</a
            >
          </p>
          <p>React Hooks um mit GraphQL Services zu kommunizieren</p>
          <p>
            Stellt einen <b>globalen Cache</b> zur Verfügung, um konsistente Daten in der ganzen
            Anwendung sicherzustellen
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Apollo Client DevTools</h3>

          <p>Browser-Erweiterung, stellt z.B. den Inhalt des Caches dar</p>

          <ul>
            <li>
              <a
                href="https://chrome.google.com/webstore/detail/apollo-client-devtools/jdkknkkbebbapilgoeccciglkfbmbnfm"
                >Chrome</a
              >
            </li>
            <li>
              <a href="https://addons.mozilla.org/de/firefox/addon/apollo-developer-tools/"
                >Firefox</a
              >
            </li>
          </ul>
        </section>

        <section data-markdown>
          <textarea data-template>
### Apollo Client

* Das `ApolloClient`-Objekt ist unter anderem für den Netzwerkverkehr, den Cache
            und Fehlerbehandlung zuständig
* Der `ApolloClient` ist React-unabhängig und kann auch mit anderen JavaScript-Frameworks
            verwendet werden.
* ```javascript
  import ApolloClient from "apollo-client";

  const client = new ApolloClient({
    link: new HttpLink({uri: "http://localhost:4000"}),
    cache: new InMemoryCache()
  }};
  ```

---

### Link

* Mit einem `Link` wird beschrieben, wie Apollo die HTTP-Requests zum Server machen soll
  * Man kann zum Beispiel eigene HTTP Header hinzufügen
  * Auch die Konfiguration für Websockets für Subscriptions erfolgt darüber
* Für verschiedene Aufgaben gibt es verschiedene `Link`-Implementierungen, die
  hintereinander ausgeführt werden können

---

### Link

* Beispiel: Header für Authentifizierung
* ```javascript
  const authLink = setContext((_, { headers }) => {
    // get the authentication token from local storage if it exists
    const token = localStorage.getItem("publy.token");
    if (!token) {
      return headers;
    }
    // return the headers to the context so httpLink can read them
    return {
      headers: {
        ...headers,
        Authorization: `Bearer ${token}`,
      },
    };
  });
  ```

---
<!-- .slide: data-hidden="true" -->
### Subscriptions

* Um mit Subscriptions zu arbeiten, braucht man einen eigenen `Link`
  * "Reguläre" Requests (für Queries und Mutations) müssen an den HTTP-Endpunkt gehen
  * Für Subscriptions müssen die Requests über das WS-Protokoll an den WS-Endpunkt gehen
* Es gibt einen eigenen Link dafür: `GraphQLWsLink`
* ```javascript
  const wsLink = new GraphQLWsLink(
    createClient({
      url: "ws://localhost:8080",
    })
  );
  ```

---
<!-- .slide: data-hidden="true" -->
### Subscriptions

* Mit einem _Splitter_ kann ausgewählt werden, mit welchem `Link` ein Request an den Server gesendet werden soll
* Damit können Subscriptions mit dem eigenen Websocket-Link ausgeführt werden
* ```javascript
  const wsLink = ...;
  const httpLink = ...;

  const remoteLink = split(
    // split based on operation type
    ({ query }) => {
      const def = getMainDefinition(query);
      return (
        def.kind === "OperationDefinition" && def.operation === "subscription"
      );
    },
    wsLink,
    httpLink
  );
  ```

---
<!-- .slide: data-hidden="true" -->
### Links

* Die Links werden beim erzeugen des Apollo Clients aneinander gehängt
* ```javascript
  const authLink = ...;
  const remoteLink = new HttpLink(...);
  const client = new ApolloClient({
    link: ApolloLink.from([authLink, remoteLink]),
    cache: new InMemoryCache()
  });
```


          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Apollo React Client</h3>
          <p>
            Die Komponenten bzw. die React-spezifische API des Apollo Clients, benötigt Zugriff auf
            den ApolloClient
          </p>
          <p>Das Client-Objekt muss der Anwendung bereitgestellt werden</p>
          <p>
            Dazu wird die <code>ApolloProvider</code>-Komponente verwendet, die allen
            darunterliegenden Komponenten Zugriff auf den ApolloClient ermöglicht:
          </p>

          <pre class="fragment"><code class="javascript">
import { ApolloProvider } from "@apollo/client";

const client = ...;

const root = ReactDOM.createRoot(document.getElementById("root"));

root.render(
    &lt;ApolloProvider client={client}>
      &lt;App />
    &lt;ApolloProvider>
  );
</code></pre>
          <p class="fragment">
            (Der Apollo Client verwendet intern die
            <a ref="https://reactjs.org/docs/context.html">React Context API</a>)
          </p>
        </section>
        <section>
          <h3>Apollo GraphQL Client in React</h3>
          <p>Live: workspace-graphql</p>
          <p>👉 PostListPage.tsx mit <b>useQuery</b></p>
        </section>
        <section data-markdown="">
          <textarea data-template>
### GraphQL Operationen beschreiben

* GraphQL Operationen können inline oder in einer eigenen Datei beschrieben werden
* Inline: mit der `gql` [Tagged Template Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates) direkt im Code
* Die `gql`-Funktion erzeugt ein **GraphQL Document Object**, das die geparste Operation enthält
    * Dieses Objekt verwenden wir zum Ausführen der Operation
* ```javascript
  import { gql } from "@apollo/client";

  const PostListPageQuery = gql`
    query PostListPageQuery {
      posts {
        id
        title
        teaser(maxLength: 20)
        date
      }
    }
  `;
  ```
* Um die GraphQL-Operationen in einer eigenen Datei abzulegen und zu importieren, müsst ihr [Euer Setup anpassen](https://create-react-app.dev/docs/loading-graphql-files/)
  * Wenn ihr mit dem [GraphQL Codegenerator](https://www.graphql-code-generator.com/) arbeitet, braucht ihr das _nicht_


---

### Verwenden des Apollo React Clients
* Apollo stellt für die drei GraphQL Operationstypen jeweils eigene
              Hooks zur Verfügung:
  * [useQuery](https://www.apollographql.com/docs/react/data/queries/#usequery-api) bzw. [useLazyQuery](https://www.apollographql.com/docs/react/data/queries/#manual-execution-with-uselazyquery)
  * [useMutation](https://www.apollographql.com/docs/react/data/mutations/#usemutation-api)
  * [useSubscription](https://www.apollographql.com/docs/react/data/subscriptions/#usesubscription-api-reference)
* Die Hooks funktionieren alle ähnlich:
  * Sie erwarten ein Dokument mit einer GraphQL Operation (Ergebnis von `gql`)
  * Verhalten kann mit weiteren Argumenten konfiguriert werden, z.B. Setzen von Variablen
  * Der Rückgabetyp ist ein Objekt mit Informationen über den Request (loading, data, error). Bei
    `useMutation` kommt kommt außerdem eine Funktion zum Ausführen der Mutation zurück

---

### useQuery: GraphQL Query ausführen
<!-- .slide: class="left" -->
* Der `useQuery`-Hook führt einen GraphQL aus:
* ```typescript
  const PostListPageQuery = gql`...`;
  function PostListPage() {
    const { loading, error, data } = useQuery(PostListPageQuery);

    if (loading) {
      return <h1>Loading, please wait...</h1>;
    }

    if (error) {
      return <h1>GraphQL Failed: {error.toString()}</h1>;
    }

    return &lt;PostList posts={data.posts} />;
  }
  ```
---

### useQuery - Lebenszyklus
* `useQuery` führt den übergebenen Query automatisch aus, sobald die Komponente _gemounted_ wurde
* Sobald der Request läuft, gibt die Funktion ein Objekt zurück, in dem `loading` auf `true` gesetzt ist. Damit kannst Du z.B. einen Loading Indikator anzeigen
* Sobald die Antwort des Queries ankommt, wird deine Komponente erneut gerendert
  * Der useQuery-Hook gibt nun ein Objekt zurück, in dem entweder <code>error</code> oder
              `data` gesetzt ist und `loading` nun `false` ist.
  * Du kannst die Informationen nutzen, um die Darstellung zu aktualisieren
  * Wenn der Request erfolgreich war, aktualisiert Apollo den globalen Cache mit den
              geladenen Daten
  * _Alle_ sichtbaren Komponenten, die (Teile der) geladenen Daten darstellen,
              werden automatisch aktualisiert

---

### useQuery: Variablen
* GraphQL Queries können Variablen enthalten
* Das (optionale) zweite Argument von `useQuery` ist ein Objekt mit Konfigurationsoptionen
* Mit diesem Argument kannst Du Variablen an deinen Query übergeben
* ```graphql
  const PostPageQuery = gql`
    query PostPage($postId: ID!) {
      post(postId: $postId) {
      id title date body
      user { name }
    }
  }
  
  `;
  ```
* ```typescript
  function PostPage() {
    // Example: Receive postId from URL params
    const { postId } = useParams();

    const { loading, error, data } = useQuery(PostPageQuery,
      {
        variables: { postId }
      }
    );
    // ...
  }
  ```
---
### Apollo Hooks mit TypeScript
* Die Apollo Hooks können mit Typ-Parametern typsicher gemacht werden.
* In der Regel können zwei Parameter angegeben werden:
  * `TData`: beschreibt, wie die gelesenen Daten aussehen (`data`-Knoten)
  * `TVariables`: beschreibt, ob/wie benötigte Variablen aussehen
* ```typescript
  const PostPageQuery = gql`...`;

  type IPostPageQuery = {
    id: String, title: String, date: string, body: string, user: { name: string } }
  }

  type PostPageVariables = { postId: string }

  function PostPage({postId}: {postId: string}) {
    const result = useQuery<PostPageQuery, PostPageVariables>({
            variables: { postId });

    result.data?.id; // OK
    result.data?.content; // ERROR content not in data
    // ...
  }
  ```
---
### Das data-Field  
* Das `data`-Field enthält im Erfolgsfall die geladenenen Daten
* Das `data`-Field ist in TypeScript aber _immer_ optional (`TData | undefined`), da es
  im Fehlerfall nicht gesendet wird, und in GraphQL Fehler und/oder Daten kommen können.
* Deswegen vor der Verwendung prüfen:  
  * ```typescript
    const {data} = useQuery<...>();

    data.story.id; // ERROR: data might be undefined
    if (!data) {
      return <h1>No Data!</h1>;
    }
    data.story.id; // OK
    ```
* Alternativ: eine TypeScript Type-Assertion-Funktion bauen:
  * ```typescript
    function assertData<T>(t: T): asserts t is NonNullable<T> {
      if (!t) {
        throw new Error("Data not defined");
      }
    }

    // In der Komponente:
    const { data, loading, error } = useQuery<...>();
    // data hier TData | undefined

    if (loading) { ... }
    if (error) { ... }

    assertData(data);

    // data hier TData
    ```
---
### Übung: Query ausführen

* Wir arbeiten im Verzeichnis `blog-example/workspace-graphql`
* Die `PostListPage` soll eine Liste von Post Teasern anzeigen
* Ergänze in `src/PostListPage.tsx` den dazu notwendigen Code
* In der Datei findest Du TODOs mit weiteren Informationen
* Eine mögliche Lösung findest Du in der Datei <code>PostListPage<b>_useQuery.txt</b></code> in `steps/30-graphql-with-typescript`

---
### TypeScript Code generieren
* <!-- .element: class="demo" --> PostListPage Query mit generierten Hooks
* Das Project [GraphQL Code Generator](https://www.the-guild.dev/graphql/codegen) bietet Code Generatoren für eine Reihe von GraphQL Frameworks, u.a. Apollo/React
* Generiert werden können damit:
  * Typen für das Query-Ergebnis (`TData`)
  * Variablen (`TVariables`)
  * Typen für verwendete Fragmente
  * Fertige Hook-Funktionen

---
### Code Generator: Konfiguration
* Je nach Konfiguration sucht der Generator nach `.graphql`-Dateien mit Queries und/oder `gql`-Funktionen
* Die Typen werden in eine Datei (z.B. `generated.tsx`) geschrieben
* Der Generator braucht Zugriff auf das Schema (lokal oder remote)
* Der Generator kann im watch-Modus betrieben werden, dann wird automatisch neu generiert, wenn neue Queries geschrieben werden
* ```yml
  overwrite: true
  schema:
    # Remote Schema:
    - "http://localhost:4000/graphql"
    # ...oder aus lokaler JS, TS, GraphQL oder JSON-Datei:
    - "../../backend-graphql/src/schema.js"
  # In welchen Dateien soll nach GraphQL Queries gesucht werden?
  documents: "./src/**/{*.graphql,*.tsx}"
  # Was (und wohin) soll generiert werden:
  generates:
    src/generated/graphql.tsx:
      plugins:
        - "typescript"
        - "typescript-operations"
        - "typescript-react-apollo"
```
* Empfehlung: Code Generator auch im CI Build ausführen lassen!

---
### Code Generator
* _Empfehlung_: Typen und Hooks generieren lassen
* Die generierten Hooks sind "nur" Wrapper-Funktionen um `useQuery`, `useMutation`, ersparen
  aber das hinschreiben der Typ-Informationen und des Dokuments mit dem Query
* ```typescript
  function PostPage({postId}: {postId: string}) {

    // useQuery von Hand:
    const { data } = useQuery<IStoryPageQuery, PostPageQueryVariables>(
            PostPageQuery, { variables: { postId } });

    // generierter Hook:
    const { data } = usePostPageQuery({ variables: { postId } });

    // data-Objekte in beiden Fällen gleich
    // ...
  }
  ```
---
### Code Generator: Fragmente
* * <!-- .element: class="demo" --> Beispiel: PostListPage fragt auch User ab
* Für verwendete Fragmente wird ein eigener TypeScript-Typ generiert, das kann praktisch
  sein, wenn man Typen für Teile eines Queries benötigt.
* Beispiel:
* ```graphql
  query { posts { user { id name } } }
```
* Generierter Typ (konzeptionell):
* ```typescript
  type PostsQuery = { posts: Array<{ user: { id: string, name: string } }> }
  ```
* Um nur den Typen für den User zu ermitteln (z.B. um in einer Komponente als Property zu verwenden),
 kann man schreiben:
* ```javascript
  type UserType = PostsQuery["posts"][0]["user"]; // 🤯 😱
  ```
* Einfacher mit einem Fragment:
* ```graphql
  fragment UserFragment on User { id name }
  query { stories { user { ...UserFragment } } }
  ```
* Nun wird ein `UserFragment`-Typ generiert:
* ```typescript
  type UserFragment = { id: string, name: string }; // 😊
  ```
---
### Übung: Queries mit dem Codegenerator

* Stelle die `PostListPage`-Komponente auf den generierte Query-Hook um
* Im Workspace ist der Codegenerator installiert und eingerichtet
* Die Hook-Funktionen sind auch schon generiert
* Ersetze in der `PostListPage`-Komponente den `useQuery`-Aufruf durch den generierten Hook
* Eine Lösung findest Du in `steps/30-graphql-with-typescript`

---
### useQuery: Caching
* Wenn deine Komponente erneut gerendert wird, wird dein Query
            **nicht erneut ausgeführt**, sofern Apollo das Ergebnis noch im Cache findet
* <!-- .element: class="demo" -->Netzwerk-Tab
* <!-- .element: class="demo" -->Zwischen Einzel-Ansichten wechseln
---

### Der Apollo Cache
* Apollo _normalisiert_ die Daten bevor sie in den Cache gelegt werden:
* Für jedes Objekt, das als Teil deines Queries geladen wurde (egal auf welchem Level),
            Apollo ermittelt den **typename** (`__typename`-Feld)
  * Das `__typename`-Feld wird dafür automatisch allen Queries von Euch
            hinzugefügt!
* Für jedes Objekt extrahiert Apollo dessen `id`
  * Wenn das `id`-Feld eines Objektes nicht `id` heißt, muss das in der
            Konfiguration von Apollo gesetzt werden
  * **Empfehlung:** *Immer* das `id`-Feld in jedem Objekt in jedem Query
            abfragen!
* Achtung! Listen werden *nicht* aktualisiert, bzw. nicht erweitert/gekürzt
---

### Der Apollo Cache: Aktualisierung
* Es gibt mehrere Möglichkeiten, den Cache zu aktualisieren:
  * [Refetch Function](https://www.apollographql.com/docs/react/data/queries/#refetching)
  * [Fetch Policy](https://www.apollographql.com/docs/react/data/queries/#setting-a-fetch-policy)
  * [Polling](https://www.apollographql.com/docs/react/data/queries/#polling)
  * Für Paginierung von Listen mit der [Fetch more](https://www.apollographql.com/docs/react/pagination/core-api/#the-fetchmore-function)-Funktion
  * [Per Subscription](https://www.apollographql.com/docs/react/data/subscriptions/#subscribing-to-updates-for-a-query)
* Nach dem Ausführen einer Mutation...  
  * ...direkt mit der [Cache API](https://www.apollographql.com/docs/react/data/mutations/#updating-the-cache-directly)
  * ...mit [refetchQueries](https://www.apollographql.com/docs/react/data/mutations/#refetching-queries)

---
### Refetch Funktion
* `useQuery` liefert eine **refetch**-Funktion, die Du verwenden kannst, um
            den Query erneut auszuführen (z.B. nach Klick auf einen "Aktualisieren"-Button)
* Bei Bedarf kannst Du der `refetch`-Funktion neue Variablen übergeben
  * Zum Beispiel um eine weitere Seite eines Such-Ergebnisses zu laden
* ```javascript
  function PostListPage() {
    const { loading, error, data, refetch } = usePostListPageQuery();

    if (loading) {
      return <h1>Loading, please wait...</h1>;
    }

    if (error) {
      return <h1>GraphQL Failed: {error.toString()}</h1>;
    }

    return <PostList posts={data.posts} onRefetch={refetch} />;
  }

  function PostList({posts, onRefetch}) {
    return <div>
      <button onClick={onRefetch}>Refresh</button>
      ...
    </div>
  }
  ```
---
### Fetch Policy
* <!-- .element: class="demo" --> `fetchPolicy` für `PostList` einstellen (`network-only`)
* Mit einer Fetch Policy kannst Du bei `useQuery` einstellen, wann dein Query
            erneut ausgeführt werden soll
  * **cache-first**: Wenn die angeforderten Daten bereits im Cache sind, werden sie aus
              dem Cache zurückgegeben, sonst vom Backend geladen (Default)
  * **cache-and-network**: Falls vorhanden, Daten aus dem Cache zurückgeben, aber in
              jedem Fall auch einen Backend-Request auszuführen, um ggf. aktualisierte Daten zu
              laden (Schnelle Darstellung, die ggf. kurze Zeit später aktualisiert wird)
  * **network-only**: Immer Daten vom Backend laden (keine Daten vom Cache verwenden),
              aber mit dem Ergebnis den Cache aktualisieren
  * **no-cache**: Immer Daten vom Backend laden und auch nicht den Cache aktualisieren
  * **cache-only**: Nur Daten vom Cache verwenden. Wenn die Daten darin nicht gefunden
              werden, wird kein Ergebnis zurückgeliefert
---

### Fetch Policy: Beispiel
<!-- .slide: class="left" -->
* ```javascript
  function PostPage() {
    const { postId } = useParams();

    const { loading, error, data } = useQuery(PostPageQuery,
      {
        variables: { postId },
        fetchPolicy: "network-only"
      }
    );
    // ...
  }
  ```
---
### Polling
* Du kannst ein `pollInterval` (Zeit in ms) als Query Option angeben. Apollo
            führt dann den Query dann in dem angegebenen Interval automatisch neu aus und aktualisiert den Cache mit den gelesenen Daten
* ```javascript
  function PostListPage() {
    const { loading, error, data } = useQuery(PostListPageQuery,
      { pollInterval: 1500 }
    );

    // bzw:
    const { loading, error, data } = usePostListPageQuery(
      { pollInterval: 1500 }
    );

    // ...wie gesehen...
  }
  ```
---


### Apollo GraphQL: Mutations
<!-- .slide: class="left" -->

* Ausführen von Mutations ist ähnlich wie das Ausführen eines Queries
* Hook: [useMutation](https://www.apollographql.com/docs/react/data/mutations/#executing-a-mutation)
* Der `useMutation` Hook gibt ein Array (Tuple) mit zwei Einträgen zurück:
  1. Eine Funktion zum Ausführen der Mutation (z.B. nach einer Benutzerinteraktion)
  2. Das Ergebnis-Objekt, das wir schon bei `useQuery` gesehen haben
            (zusätzlich: ein `called`-Property, das angibt, ob die Mutation bereits mind. einmal ausgeführt wurde)
* ```jsx
  function PostEditorPage() {
    const [mutate, { error, data, called }] = useMutation<IAddPostMutation, IAddPostVariables>
            (AddPostMutation);

    // oder generiert:
    const [mutate, { error, data, called }] = useAddPostMutation();

    function addPost(postInput: {title: string, body: string} ) {
      // Verwendung von mutate hier Typsicher, da TS
      // das 'variables'-Objekt von useMutation kennt
      mutate({
          variables: { input: postInput }
      });
    }

    const errorMessage = error ? ... : null;

    if (called && !errorMessage) {
      // Mutation has been executed and was successful
      return &lt;SuccessConfirmation />;
    }

    // Mutation hasn't been run or failed with an error
    return <PostEditor errorMessage={errorMessage} />
  }
  ```
---

### Die mutate-Funktion

* Der `mutate`-Funktion können (fast) alle Argumente übergeben werden, die
  auch an `useMutation` übergeben werden können (insb. Variablen)
* Beim Aufruf der `mutate`-Funktion wird die Mutation ausgelöst und die Komponente
  wird mit neuen Ergebnissen (oder Fehlern) neu gerendert (wie bei `useQuery`)
* Die `mutate`-Funktion liefert ein Promise zurück, das mit dem Ergebnis
  der Mutation (`data` oder `errors`) aufgelöst wird, sobald das Ergebnis da ist
* Damit kannst Du weitere Logik unmittelbar nach dem Abschluss der Mutation ausführen
* ```jsx
  function PostEditorPage({onPostSaved}: {onPostSaved: () => void}) {
    const [mutate, { error, data, called }] = useAddPostMutation();

    async function addPost(postInput: {title: string, body: string}) {
      const {data, error} = mutate({
          variables: { input: postInput }
      });

      if (data) {
        // Beispiel: Alles OK, jetzt Redirect machen
        history.push("/...");
        // ...oder Callback von Oberkomponente aufrufen:
        onPostSaved();
      }
    }
  ```

---
### Nach einer Mutation... wird der Cache automatisch aktualisiert (eventuell)
* Wenn deine Mutation ein Objekt zurückliefert, das sich bereits im Cache befindet, wird
            es dort aktualisiert
* PostPage, Like vergeben <!-- .element: class="demo" -->             
* Beispiel: Du *aktualisierst* eine existierende Story und das Ergebnis der
            Mutation enthält irgendwo die aktualisierte Story (zumindest die aktualisierten Teile).
  * Voraussetzung: im Ergebnis kommt auch die `id` der Story vor
* ```javascript
  const LikePostMutation = gql`
    mutation {
      likePost(postId: "P1") {
          id
          likes
      }
    }
  ```
* In diesem Beispiel kann Apollo das Objekt <b>P1</b> im Cache automatisch aktualisieren
  (neue Anzahl von likes)

---
### Den Cache nach einer Mutation aktualisieren
* Mit [refetch Queries](https://www.apollographql.com/docs/react/data/mutations/#refetching-queries) kannst Du eine Liste von Queries angeben, die erneut ausgeführt werden, wenn
              eine Mutation erfolgreich war

* ```typescript
  import { useAddBlogPostMutation, PostListPageDocument } from "./generated/graphql";


  async function savePost(post: NewBlogPost) {
    const { data } = await mutate({
      variables: { postData: post },
      refetchQueries: [
        {
          query: PostListPageDocument
        }
      ]
    });
  }
  ```
* Mit der [update Function](https://www.apollographql.com/docs/react/data/mutations/#updating-the-cache-directly) kannst Du den Cache direkt per API manipulieren, sobald deine Mutation erfolgreich
              war

---
### Übung: eine Mutation
* Die Logik zum Anlegen eines BlogPosts implementieren
* Die Mutation (`AddBlogPostMutation`) ist schon fertig und der Code dafür generiert
* In `PostEditorPage` musst Du den Code vervollständigen, siehe dort für weitere Informationen
* Was musst du tun, damit der neu gespeicherte Blog Post auch in der Liste auf der ersten Seite angezeigt wird?
* Mögliche Lösung in `steps/9_graphql-with-typescript`

---
### Testen vom Client (ggf. Deep Dive)

* Wenn ihr GraphQL Anwendungen testen wollt, müsst ihr möglicherweise den Netzwerkverkehr mocken
* Dazu könnt ihr die besprochenen Techniken verwenden (jest-fetch-mock, msw, etc.)
* Alternativ: [MockedProvider](https://www.apollographql.com/docs/react/development-testing/testing) von GraphQL
* Damit könnt ihr Ergebnisse von Queries setzen
* Der Apollo Client liefert dann die Mock-Ergebnisse zurück und führt keine Netzwerkanfragen aus
* 🧑‍💻 Beispiel: Test für PostListPage
* ```typescript
  test("rendering works", () => {
    render(
        <MockedProvider mocks={[mock]}>
          <PostListPage />
        </MockedProvider>
    );
  })
  ```

---

### MockResponse

* Dem `MockedProvider` übergebt ihr eine Liste mit `mocks`
* Das sind `MockResponse`-Objekte, die aus zwei Properties bestehen:
  * `request`: Gibt an, für welchen GraphQL Request die Antwort zurückgeliefert werden soll
    * Ihr könnt einen Query angeben (Achtung! Der muss genau dem Query in Eurer Anwendung entsprechen!)
    * Ihr könnt zusätzlich Variablen für den Query angeben, die Eure Anwendung übergibt
  * `result`: Enthält die typischen Ergebnisse einer GraphQL Operation: entweder `data` oder eine Liste mit `GraphQLError`-Objekten (`errors`)-Knoten
* Der `MockResponse`-Typ in TypeScript ist typisiert, so dass ihr dort als Typ-Parameter den generierten Query-Typen angeben kann
* Dann ist zumindest das `result`-Feld typsicher

---
### MockResponse: Beispiel für data

```typescript
  const mock: MockedResponse<PostListPageQuery> = {
    request: {
      query: PostListPageDocument,
      operationName: "PostListPage"
    },
    result: {
      data: {
        posts: [
          {
            date: "2022-02-23",
            title: "Hello World",
            teaser: "Lorem ipsum",
            id: "P1"
          }
        ]
      }
    }
  };

  test("rendering works", async () => {
    render(
        <MockedProvider mocks={[mock]}>
          <PostListPage />
        </MockedProvider>
     );
     // Loading Indicator ist sofort sichtbar:
     expect(screen.getByRole("heading", {name: /please wait/i})).toBeInTheDocument();
    
     // Achtung Asynchron:
     expect(await screen.findByRole("heading", {name: /hello world/i})).toBeInTheDocument();
  });
```
---
### MockResponse: Beispiel für error

```typescript
const mock: MockedResponse<PostListPageQuery> = {
  request: {
    query: PostListPageDocument,
    operationName: "PostListPage"
  },
  result: {
    errors: [new GraphQLError("au weia!")]
  }
};

// Verwendung wie gesehen
```

---
### Übung: GraphQL Requests testen

* In `PostPage.test.tsx` gibt es zwei Testfälle, die fertig implementiert werden müssen!
* Du musst dort die Mocks korrekt definieren, ein Anfang findest Du dort bereits
* Der generierte TypeScript-Typ der Queries ist `PostPageQuery`.
* Tipp: mit TypeScript oder im Netzwerk-Tab der laufenden Anwendung prüfen, wie die Daten aussehen, die zurückgegeben werden müssen.
* Du kannst die Tests ausführen mit: `npm test -- PostPage`
* Eine mögliche Lösung findest Du in `steps/30-graphql-with-typescript/src/__tests__`
* Wenn Du fertig bist, bitte Hand heben! 🙋🏻‍♀️

</textarea
          >
        </section>

        <section id="t-apollo-react-deep-dive">
          <h1>Apollo React Client</h1>
          <h2>Deep dive</h2>
        </section>
        <section data-markdown>
          <textarea data-template>
### Vorbereitung
* Bitte das Repository klonen: `git clone https://github.com/nilshartmann/react18-training`
* Das GraphQL Backend starten:
* ```bash
  cd blog-example/backend-graphql
  npm install 
  npm start
  ```
* GraphQL Explorer sollte auf [http://localhost:4000](http://localhost:4000) laufen
* Wir arbeiten dann im Verzeichnis `blog-example/workspace-graphql-advanced`
* Dort die Anwendung starten:
* ```bash
  cd blog-example/workspace-graphql-advanced
  npm install 
  npm start
  ```
* Anwendung sollte jetzt auf [http://localhost:3000](http://localhost:3000) laufen
        
  </textarea
          >
        </section>
        <section data-markdown>
          <textarea data-template>
### Wiederholung: Der Apollo Cache

* <!-- .element: class="demo" --> Apollo Dev Tools mit fertiger Anwendung
* <!-- .element: class="demo" --> Einzelne Artikel anzeigen
* <!-- .element: class="demo" --> "Like" vergeben

---


### Aktualisieren von Listen
* Wenn neue Daten für eine Liste geladen werden (oder welche entfernt werden),
  weiß Apollo nicht, wie damit umzugehen ist
* Der Cache kann dann nicht automatisch aktualisiert werden
* Beispiel:
  * Nach dem PostEditor wird der neue Post nicht auf der PostListPage angzeigt
  * <!-- .element: class="demo" --> Zeigen, was passiert, wenn refetchQueries entfernt wird
  * Zusätzliche Posts werden auf der PostList gelesen (z.B. Button "Mehr laden")
  * Müssen die neuen/zusätzlichen Posts am Anfang oder Ende der bestehenden Liste eingefügt werden?
  * Sollen sie dort überhaupt eingefügt werden?

---
<!-- .slide: data-hidden="true" -->
### Aktualisieren von Listen
* Grundsätzlich können Listen mit verschiedenen Strategien aktualisiert werden:
  * **update**: Nach einer Mutation, die ein neues Objekte erzeugt (oder löscht), soll das Objekt
  in eine Liste hinzugefügt (oder gelöscht) werden
    * Sehen wir uns gleich exemplarisch an
  * **fetch more**: Jemand klickt z.B. auf "Weitere Einträge laden"-Link
    * Beispiel: Liste von Posts in PostList-Page
  * **subscription**: Eine Subscription liefert neue Elemente, die (auch) in eine bestehende Liste eingefügt werden
* In jedem Fall müssen wir dazu implementieren, *wie* die neuen Daten in die gecachten Listen kommen
### Die Apollo Cache API
* Du kannst den Query auslesen (mit einem GraphQL Query!)
* Du kannst den Cache direkt modifizieren, zum Beispiel Objekte hinzufügen und löschen
* 🫣 Ich bin kein großer Freund der Cache API, finde sie sehr verwirrend und übersichtlich und versuche deren Benutzung zu vermeiden, wenn es irgendwie geht

---

### Das Apollo Cache Objekt
* Das `Cache`-Objekt bietet Funktionen zum Zugriff auf den Cache
* Das Objekt erhälst Du zum Beispiel über den `Client` oder als Argument in verschiedenen Callback-Funktionen
* Du kannst Daten aus dem Cache lesen, in dem Du die `readQuery`-Funktion verwendest, die ein GraphQL Query(!) erwartet
  * ```javascript
    const ReadPostsFromCache = gql`{ posts { id } }`;

    const posts = cache.read({query: ReadPostsFromCache});
    ```
* Der `read`-Funktion kannst Du einen Typ-Parameter mit dem Ergebnis des Queries angeben
  * ```javascript
    const ReadPostsFromCache = gql`{ posts { id } }`;

    const posts = cache.read<{ posts: Array<{id: string}>}>({query: ReadPostsFromCache});
    ```
* Mit `writeQuery` kannst Du neue Daten setzen. Dazu gibts Du einen Query an und die neuen Daten dafür. Apollo mergt die dann im Cache zusammen:
* ```javascript
    const posts = cache.read({query: ReadPostsFromCache});
    const newPosts = [...posts, { id: "P1000", title: "..." } ];

    cache.write({
      query: ReadPostsFromCache,
      data: newPosts
    })
  ```
* `readFragment`/`writeFragment` und `modifiy` gibt es weitere Möglichkeiten [zur Interaktion mit dem Cache](https://www.apollographql.com/docs/react/caching/cache-interaction)
  * Diese können insbesondere besser geeignet sein, wenn Objekte modifziert werden sollen, die tiefer verschachtelt sind

---
### Cache nach einer Mutation aktualisieren
* Mit der `update`-Function von `useMutation` kannst Du den Cache direkt verändern
* Diese Funktion wird nach dem Ausführen der Mutation von Apollo aufgerufen
  * Achtung! Die Funktion wird auch aufgerufen, wenn die Mutation fehlgeschlagen ist
* Die Funktion bekommt zwei Parameter übergeben:
  1. Das `cache`-Objekt
  2. Ein Objekt, mit der Antwort der Mutation (`data` und `errors`)

* ```javascript
  const ReadPostsFromCache = gql`{ posts { id } }`;

  function PostEditorPage() {
    function savePost(newPost) {
      mutate({
        variables: {...},
        update: (cache, { data, errors }) => {
          const existingPosts = cache.readQuery(...);

          // Liste mit neuen Daten erzeugen
          const newPosts = [data.newPost, ...existingPosts];

          // Daten schreiben
          cache.writeQuery({
            query: ReadPostsFromCache,
            data: { posts:  newPosts }
          });
      })
    }

    return ...;
  }
  ```
---
### Cache nach einer Mutation aktualisieren
<!-- .slide: class="left" -->
* Beispiel mit TypeScript und Prüfungen
* ```javascript
  const ReadPostsFromCache = gql`{ posts { id } }`;

  function PostEditorPage() {
    function savePost(newPost) {
      mutate({
        variables: {...},
        update: (cache, {data}) => {
          if (!data) { return; }
          const newBlogPost = data.newPost.blogPost;

          const existingPosts = cache.readQuery<{ posts: Array<{ id: string }> }>({
            query: ReadPostsFromCache
          });

          const newPosts = existingPosts ? [newBlogPost, ...existingPosts.posts] : [newBlogPost];
          
          cache.writeQuery({
            query: ReadPostsFromCache,
            data: { posts: [data.newPost, ...existingPosts] }
          });
      })
    }

    return ...;
  }
  ``` 

---
### Aktualisieren von Listen: Pagination mit fetchMore
<!-- .slide: data-hidden="true" -->
* Anwendungsfall:
  * es gibt eine Liste, durch die durchgeblättert werden kann
  * die jeweils neu geladenen Objekte sollen der Liste auch im Cache hinzugefügt werden
  * Vorteil: wenn Benutzer dann nochmal zurückblättert, sind die Objekte schon da
* Dazu liefert `useQuery` eine weitere Funktion zurück: `fetchMore`

* Diese Funktion akzeptiert im einfachsten Fall neue Query _Variablen_ und führt den Query neu aus
* ```javascript
  function FeedPage() {
    const { loading, data, error, fetchMore } = useFeedPageQuery();

    // ...

    const handleFetchMore = () => {
      fetchMore({
        variables: {
          page: data.stories.page.pageNumber + 1, // fetch next page
        },
      });
    };

    return <div>
       {data.page.hasNext && <button onClick={handleFetchMore}>Next</button>}
       // ...
    </>
  }
  ```
* Die geladenen Daten landen aber nicht im Cache 😭
* <!-- .element: class="demo" --> Cache im DevTools mit fetchMore
---
### Type Policy
<!-- .slide: data-hidden="true" -->
* Mit einer **Type Policy** muss die Aktualisierung des Caches für ein Feld angepasst werden
  * Achtung 1: Das ist - je nach Schema, Query und Fachlichkeit - nicht trivial!
  * Achtung 2: TypeScript-Support an der Stelle nur eingeschränkt!
* In der Cache-Konfiguration beim Erzeugen des Apollo Clients:
* ```javascript
  const apolloClient = new ApolloClient({
    // ...
    cache: new InMemoryCache({
      typePolicies: {
        Query: {
          fields: {
            stories: {
              keyArgs: false,
              merge(
                existing: StoryConnection | undefined | null,
                incoming: StoryConnection
              ) {
                if (!existing) { return incoming; }
                const merged = {
                  page: incoming.page,
                  stories: [...existing.stories, ...incoming.stories],
                };
                return merged;
              }  }  }  } }
            }),
        });
  ```
  * <!-- .element: class="demo" -->Der Cache in den Developer-Tools mit fetchMore-Funktion in FeedPage

---
### Ausblick: Aktualisieren des Caches mit Subscriptions
<!-- .slide: data-hidden="true" -->
<!-- .slide: class="left" -->
* Bei den bisher gesehen Aktualisierungen, hat der Client die Aktualisierung
  ausgelöst.
* Dadurch werden Änderungen an Daten, die nicht vom Server vorgenommen werden, aber nicht
  berücksichtigt
* Beispiel: Anderer Benutzer erzeugt einen Kommentar
* Man kann das Query-Ergebnis (insb. für Listen) mit einer Subscription aktualisieren
* Beispiel: onNewComment Subscription
---
### Ausblick: Aktualisieren des Caches mit Subscriptions
<!-- .slide: data-hidden="true" -->
<!-- .slide: class="left" -->
* `useQuery` stellt dazu die Funktion `subscribeToMore` zur Verfügung
* Dieser Funktion wird übergeben:
  * Als Typ-Parameter der Name des Typs, der das Ergebnis der Subscription beschreibt
  * Als Parameter ein Objekt:
    * mit `document` (Ergebnis des `gql`-Aufrufs mit der Subscription bzw. des generierten Codes)
    * evtl. `variables` für die Mutation
    * `updateQuery`-Funktion
* Immer wenn die Subscription neue Daten liefert, wird die Callback-Funktion `updateQuery`
  mit den alten und neuen Daten aufgerufen
* In `updateQuery` können die neuen Daten dem Cache hinzugefügt werden
* <!-- .element: class="demo" --> Cache Verhalten in Apollo Dev Tools
---
### Ausblick: Aktualisieren von Listen mit Subscriptions
<!-- .slide: data-hidden="true" -->
<!-- .slide: class="left" -->

* ```javascript
  function StoryComments({ storyId }) {

    // initial Kommentare für eine Story lesen
    const { data, loading, error, subscribeToMore } = useStoryCommentsQuery({
      variables: { storyId },
    });

    React.useEffect(() => {

      // Aktualisieren der Liste im Cache mit Subscription
      subscribeToMore<OnNewCommentSubscription>({
        document: OnNewCommentDocument,
        variables: { storyId },
        updateQuery: (prev, { subscriptionData }) => {
          // Wenn die Subscription keine Daten geliefert hat (z.B. Fehler)
          // den alten Cache-Inhalt unverändert zurückliefern
          if (!subscriptionData.data) return prev;

          // Bestehenden Cache-Inhalt ('prev') kopieren und in das
          // 'comments'-Feld den neuen Kommentar einfügen

          // Achtung! Wie das einfügen genau funktioniert, hängt natürlich
          //  immer von deiner jeweiligen Daten-Struktur ab
          const newComment = subscriptionData.data.onNewComment.newComment;
          const newData = Object.assign({}, prev, {
            comments: [newComment, ...prev.comments],
          });

          // Neuen Wert zurückliefern; dieser ersetzt dann
          // den gecachten Wert des Queries, für den diese
          // updateQuery-Funktion ausgeführt wurde
          return newData;
        },
      });
    }, [subscribeToMore, storyId]);

    return ...;
  }
  ```
---
### Übung: Den Cache manuell aktualisieren
* Implementiere die `update`-Funktion für die `addPost`-Mutation
* Versuche dabei, für `readQuery` einen TypeScript-Typen anzugeben
* Beschreibung findest Du in `workspace-graphql-advanced/src/PostEditorPage.tsx`

---
### Field Policies

* Mit einer [Field Policy](https://www.apollographql.com/docs/react/caching/cache-field-behavior) kann die Interaktion mit dem Cache beim Zugriff auf ein Feld angepasst werden
* Man kann damit konfigurieren:
  * was beim Lesen eines Feldes passieren soll
  * was beim Schreiben des Feldes in den Cache passieren soll
  * Mit `keyargs` könnt ihr Argumente eines Feldes angeben, die nicht Bestandteil des Cache-Keys sein sollen

---

### Angabe der Field Policies

* Die Policy für ein Field kann in der `Type Policy` des Parent-Typen gesetzt werden
* Die Type Policies werden in der Cache-Konfiguration gesetzt.
* Dabei handelt es sich um ein Objekt, das als Keys Namen von Objekt Typen aus Eurem GraphQL Schema enthält
* Als Wert wird jeweils ein Objekt mit dem Property `fields` übergeben.
* In diesem Objekt sind dann die Keys die Feldnamen des Typen. Die zugehörigen Werte sind dann die Field Policies
* Beispiel: eine `read`-Policy für das `title`-Field am `Post`-Typen.
  * ```javascript
    const cache = new InMemoryCache({
      typePolicies: {
        // Name des Typen: "BlogPost"
        BlogPost: {
          fields: {
            // Name des Feldes, das konfiguriert werden soll: "title"
            title: {
              read(currentTitle) { return currentTitle.toUpperCase() }
            }
          }
        }
      }
    });
  ```
---
### Details: Die read-Funktion 
* Wenn man für einen Typen nur eine `read`-Funktion definiert, kann man eine kompaktere Schreibweise wählen:
  * ```javascript
    const cache = new InMemoryCache({
      typePolicies: {
        BlogPost: {
          fields: {
            // title ist hier kein Objekt, sondern direkt read-Funktion
            title(currentTitle) { return currentTitle.toUpperCase() }
          }
        }
      }
    });
  ```
* Über den zweiten Parameter, bekommt man Zugriff auf die übergebenen Feld-Argumente
  * ```javascript
    const cache = new InMemoryCache({
      typePolicies: {
        BlogPost: {
          fields: {
            title(currentTitle, { args } ) { 
              return args.transform === "uppercase" ? currentTitle.toUpperCase() : currentTitle 
            }
          }
        }
      }
    });
  ```
* Nur sparsam (falls überhaupt) verwenden, denn in der Regel sollte ja die Logik auf dem Server ausgeführt werden
---
### Client-only Felder
* Der Apollo Client erlaubt es, das GraphQL Schema um Felder zu erweitern, die nur auf dem Client zur Verfügung stehen
* Die Logik für diese Felder wird dann in der `read`-Funktion der entsprechenden `FieldPolicy` hinterlegt
* Ist das eine gute Idee? Wofür würdet ihr das nutzen? 🤔

---
### Beispiel: Client-only Felder

* Formatiertes Datum im BlogPost
* Mit der `@client` Direktive gebt ihr an, dass das Feld ein "client-only" Feld ist
  * ```graphql
      query PostPage($postId: ID!) {
        post(postId: $postId) {
          id
          title
          date
          # Client-only Feld
          formattedDate @client
          body
          likes
        }
      }
    ```
* Zur Ermittlung des Wertes legt ihr eine FieldPolicy an:
* ```typescript
    const client = new ApolloClient({
      cache: new InMemoryCache({
        typePolicies: {
          BlogPost: {
            fields: {
              formattedDate(_, { readField }) {
                const date = readField("date");
                if (typeof date === "string") {
                  // Datum formatieren
                  return formattedDate(date); 
                }
              }
            }
          }
        }
      })
    });
  ```
---
### Client-only Felder
* Achtung: Ihr müsst auch den Code-Generator umkonfigurieren, damit der Eure Client-only-Felder kennt
* Dazu neue Schema-Datei anlegen und in die `codegen.yml`-Datei eintragen:
  * ```graphql
    #./client-schema.graphql
    directive @client on FIELD

    extend type BlogPost {
      formattedDate: String!
    }
    ```
  * Konfigurationsdatei:  
  * ```yaml
    generates:
      src/generated/graphql.tsx:
        schema: ./client-schema.graphql
      ...
    ```
---
### Reactive Variables
* [Reactive Variables](https://www.apollographql.com/docs/react/local-state/managing-state-with-field-policies#storing-and-updating-local-state-with-reactive-variables) sind eine Möglichkeit, globalen Zustand zu halten (ohne Apollo Cache)
* <!-- .element: class="demo" --> Bookmarks in der Sidebar
* <!-- .element: class="demo" --> Reactive Variables (workspace-graphql-advanced)

---
### Reactive Variablen
* <!-- .element: class="demo" --> Last clicked oder click counter o.ä.

---
### Reactive Variables
* Eine reaktive Variable wird mit `makeVar` angelegt.
  * Als Parameter wird der initial Wert übergeben
  * Als Typ-Parameter kann der TypeScript des gehaltenen Werts übergeben werden
* ```javascript
    import { makeVar } from "@apollo/client";
    const counterVar = makeVar<number>(0);
  ```
* Zurückgeliefert wird eine Funktion, die zum Lesen und Schreiben des aktuellen Wertes dient
  * Wenn die Funktion ohne Parameter aufgerufen wird, wird der aktuelle Wert zurückgegeben:
    * ```javascript
      const currentCounter = counterVar();
      ```
  * Wenn du der Funktion einen Wert übergibst, wird dieser Wert als neuer Wert gesetzt.
    * ```javascript
      counterVar(currentVar + 1);
      ```
    * Achtung! Wie bei React State ist der Wert immutable!
    * Objekte und Arrays also nicht direkt verändern, sondern kopieren und die Kopien dann ändern und setzen
  
---
### Reactive Variables: Verwendung in React
* Die React Variables sind im (React-unabhängigen) Apollo Client implementiert
* Mit dem [`useReactiveVar`](https://www.apollographql.com/docs/react/local-state/reactive-variables#usereactivevar-hook) kannst Du eine Variable in einer React Komponente auslesen
  * Wenn die Variable sich ändert, wird die Komponente neu gerendert
  * Dem Hook übergibst Du die Funktion, die `makeVar` zurückgeliefert hat
  * ```javascript
      // counter.ts
      export const counterVar = makeVar<number>(0);
    ```
  * ```javascript
      // CountView.tsx  
      function CountView() {
        const currentCount = useReactiveVar(counterVar);

        // ...
      }
    ```
  * Setzen der Variable unverändert, wie bereits gesehen
  * ```jsx
      // CountView.tsx  
      function CountView() {
        const currentCount = useReactiveVar(counterVar);

        return <button onClick={ () => counterVar(currentCount+1) }>
          Increase {currentCount}</button>
      }
    ```

---
### Reactive Variablen: Übung

* Baue das Bookmark-Feature für die Blog-Anwendung
* Im "globalen Zustand" soll eine Liste von Bookmarks gehalten werden
* Ein `Bookmark` ist ein Objekt mit zwei Eigenschaften: `title` und `path`
* Unter der Artikelvorschau (`PostTeaser` in der `PostList`) soll ein Button
  hinzugefügt werden, mit dem der Artikel den Bookmarks hinzugefügt wird
  * Der `title` soll der Titel des Artikels sein
  * Der `path` ist `/post/${post.id}` (kannst Du in der Sidebar als `Link` verwenden)
* In der Sidebar soll eine Liste aller Bookmarks angezeigt werden
  * Hinter dem Bookmark soll ein Button o.ä. sein, mit dem man den Post wieder  
    entfernen kann
  * Über den `path` des Bookmarks kannst Du auch einen Link zur Post-Ansicht bauen, wenn Du willst (`<Link to={bookmark.path}>...</Link>`)  
* Optional: 
  * Zeig im _PostTeaser_ an, ob der dargestellte Post bereits gebookmarked ist
  * Wenn ein Bookmark entfernt wird: schaffst Du es, dass nur der `PostTeaser` neu gerendert wird, der den Post aus dem gelöschten Bookmark darstellt?
* Weitere Hinweise findest Du in `bookmarks.ts`


  </textarea
          >
        </section>

        <!-- ============================================================================= -->
        <section>
          <h2>Geschafft! 😊</h2>
          <h3>Vielen Dank für Eure Teilnahme!</h3>
          <h3>Viel Spaß und Erfolg mit React!</h3>
          <p>Wenn ihr noch Fragen habt, könnt ihr mich erreichen:</p>
          <p>Mail: <a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a></p>
          <p>
            Web: <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a>
          </p>
          <p>
            Twitter: <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
        </section>
      </div>
    </div>

    <script src="slides/revealjs/reveal.js/dist/reveal.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/notes/notes.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/markdown/markdown.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/highlight/highlight.js"></script>
    <script src="slides/revealjs/config.js"></script>
  </body>
</html>
