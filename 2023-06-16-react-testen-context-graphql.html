<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>React Training</title>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"
    />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/reset.css" />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/reveal.css" />
    <link rel="stylesheet" href="slides/revealjs/reveal.js/dist/theme/solarized.css" />

    <!-- Theme used for syntax hislides/ghlighted code -->
    <link rel="stylesheet" href="slides/revealjs/highlight-js-github-theme.css" />
    <link rel="stylesheet" href="slides/revealjs/styles.css" />
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section data-state="title">
          <h2 class="title" style="font-size: 7rem">
            <b>React: Testen, Context, GraphQL</b>
          </h2>

          <h4>
            <span class="transparent-bg">
              <a href="https://nilshartmann.net" target="_blank">Nils Hartmann</a>
              |
              <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
            </span>
          </h4>
          <p style="margin-top: 4rem"></p>
          <div>
            <h3><span class="transparent-bg">Repository</span></h3>
            <p>
              <span class="transparent-bg"
                >Remote:
                <a href="https://github.com/nilshartmann/react18-training"
                  >https://github.com/nilshartmann/react18-training</a
                ></span
              >
            </p>
          </div>
          <p style="margin-top: 4rem"></p>
          <div>
            <h3><span class="transparent-bg">Slides</span></h3>
            <p>
              <span class="transparent-bg"
                >Lokal: 2023-06-16-react-testen-context-graphql.html</span
              >
            </p>
            <p>
              <span class="transparent-bg"
                >Remote:
                <a
                  href="https://nilshartmann.github.io/react18-training/2023-06-16-react-testen-context-graphql.html"
                  >https://nilshartmann.github.io/react18-training/2023-06-16-react-testen-context-graphql.html</a
                ></span
              >
            </p>
          </div>
        </section>
        <section>
          <h2>Nils Hartmann</h2>
          <p>
            <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a>
            /
            <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
          <p>
            <em>Freiberuflicher Software-Entwickler, Berater und Trainer aus Hamburg</em>
          </p>

          <div style="display: flex; justify-content: center">
            <div>
              <p>Java</p>
              <p>JavaScript, TypeScript</p>
              <p>React</p>
              <p>Single-Page-Applications</p>
              <p>GraphQL</p>
              <p style="margin-top: 20px">
                <a href="https://nilshartmann.net/workshops">Schulungen und Workshops</a>
              </p>
            </div>
            <div style="margin-left: 15px">
              <a href="https://reactbuch.de"
                ><img
                  style="max-height: 450px"
                  src="slides/images/react-buch-v2.jpg"
                /><br />https://reactbuch.de</a
              >
              <br />
            </div>
          </div>
        </section>

        <!-- ============================================================================= -->
        <section data-markdown>
          <textarea data-template>
### Zeitplan

* 08:30 - 16:00
  * 12:00 bis 13:00 Mittagspause üçù
  * Kurze Pausen zwischendurch ‚òïÔ∏è

---  
### Agenda

* Kurze Planung, welche Themen wir (wann) machen
* Miro-Board
          </textarea>
        </section>
        <section>
          <h2>Agenda</h2>
          <ul class="xx-list">
            <li>
              <a href="#/t-test">Testen mit Jest</a>
            </li>
            <li>
              <a href="#/t-context">Context API</a>
            </li>
            <li style="margin-top: 20px">
              <a href="#/t-state">Globales Zustandsmanagement mit Redux Toolkit</a>
              <ul>
                <li><a href="#/t-redux">Redux Grundlagen</a></li>
                <li><a href="#/t-rtk">Redux Toolkit</a></li>
                <li>Asynchrone Actions mit <a href="#/t-redux-thunk">Redux Thunk</a></li>
                <li>Data Fetching mit <a href="#/t-rtk-query">Redux Toolkit Query</a></li>
              </ul>
            </li>
            <li>
              <a href="#/t-apollo-react-deep-dive">Apollo Deep Dive</a>
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->

        <section id="t-test">
          <h2>Testen von React Anwendungen</h2>
        </section>
        <section data-markdown>
          <textarea data-template>
### Vorbereitung
* Das Git-Repository https://github.com/nilshartmann/react18-training klonen
* Zun√§chst das "Backend" starten, in `blog-example/backend-rest`:
  * ```bash
    cd blog-example/backend-rest

    npm install
    npm start
    ```
* Wir machen alle √úbungen im `blog-example/workspace-typescript`-Verzeichnis.
* In `blog-example/workspace-typescript/src` die Dateien `PostEditor.js` und `PostList.js` **l√∂schen**!
* Dann kopierst Du aus dem Verzeichnis <code>blog-example/steps/5-typescript/src</code> die beiden Dateien:
  * `PostEditor.tsx`
  * `PostList.tsx`
  * in den `src`-Ordner in deinem Workspace (`workspace-typescript/src`)
* Dann bitte `npm install` ausf√ºhren und die Anwendung starten:
  * ```
    cd blog-example/workspace-typescript

    npm install
    npm start
    ```  
* Einmal die Anwendung im Browser √∂ffnen, um zu sehen, ob's geht: http://localhost:3000    
          </textarea>
        </section>

        <section data-transition="slide none">
          <h2>Was testen wir?</h2>
          <ul>
            <li><b>UI-unabh√§ngige Logik</b> (zum Beispiel Backend Calls, Berechnungen etc.)</li>
            <li>
              <b>Rendering</b> (Ist die Liste der Blog Posts korrekt? Sieht das Markup aus, wie wir
              uns das vorstellen?) und <b>Interaktionen</b> (funktionieren die Event Handler, die
              Callback-Funktionen, der Programmflu√ü etc.?)
            </li>
            <li>
              <b>Verhalten im Browser</b> (z.B. korrekte, pixelgenaue Darstellung,
              Browser-spezifisches JavaScript, Arbeiten mit Browser-Technologie wie Titelzeile,
              Session Storage, Scrollbars etc)
            </li>
          </ul>
        </section>

        <section>
          <h1>Jest</h1>
          <p>
            <em
              >"Delightful JavaScript Testing" (
              <a href="https://jestjs.io/" target="_blank">https://jestjs.io/</a>)</em
            >
          </p>
          <p>Vollst√§ndige Testl√∂sung f√ºr React (und andere):</p>
          <ul>
            <li>API vergleichbar mit <a href="https://jasmine.github.io/">Jasmine</a></li>
            <li>Test Runner</li>
            <li>Specs/Assertions, Mocks</li>
            <li>Code Coverage</li>
          </ul>
        </section>
        <section>
          <h4>Jest</h4>
          <h3>Beispiel: Ein einfacher Testfall</h3>
          <pre><code class="javascript"  >// sum.js (or sum.ts)
export const sum = (a,b) => a+b;
        </code></pre>
          <pre><code class="javascript"  >// sum.test.js
import {sum} from '../sum.js';

test('sum of 2 and 2 is 4', () => {
  expect(sum(2, 2)).toBe(4);
});

test('sum of 2 and 2 is not 3', () => {
  expect(sum(2, 2)).not.toBe(3);
});
            </code></pre>
        </section>
        <section>
          <h4>Jest</h4>
          <h2>Testcases</h2>
          <p>
            <code>test</code> oder
            <code>it</code>
          </p>
          <pre><code>test('it should work', () => {
  expect(...).toBe(...);
});</code></pre>
          <pre><code>it('it should also work', () => {
  expect(...).toBe(...);
});</code></pre>
        </section>

        <section>
          <h4>Jest</h4>
          <h2>"Expectations" und "Matchers"</h2>
          <div>
            <p>
              <code>expect()</code> liefert ein <em>Expectation</em> Objekt zur√ºck, das verschiede
              <em>Matcher</em> Funktionen bereitstellt:
            </p>
            <pre><code>expect(actual).toXyz(expected);
// for example:
expect("Hello Jest").toBe("Hello Jest"); // => ok
        </code></pre>
          </div>
          <div>
            <p>Beispiele f√ºr Matchers</p>

            <pre><code>// Compare identity
expect(actual).toBe(expected);
// Compare value:
expect(actual).toEqual(expected);
// true / false / null:
expect(actual).toBeTruthy();
expect(actual).toBeFalsy();
expect(actual).toBeNull();
// Length (Array oder String)
expect(actual).toHaveLength(123);
        </code></pre>
          </div>
          <p>
            <a href="https://jestjs.io/docs/en/expect">https://jestjs.io/docs/en/expect</a>
          </p>
        </section>

        <section>
          <h4>Jest</h4>
          <h2>Mock Funktionen</h2>
          <ul>
            <li>
              <code>jest.fn()</code> erzeugt eine Mock-Funktion
              <pre><code>// Gibt undefined zur√ºck, wenn die Mock-Funktion ausgef√ºhrt wird
const aMockFn = jest.fn();

const x = aMockFn("hello", "world"); // => undefined
expect(x).toBeUndefined();
              </code></pre>
            </li>
            <li>
              Mit <code>toHaveBeenCalled</code>-Matcher-Funktionen kann gepr√ºft werden, ob der Mock
              aufgerufen wurde, wie h√§ufig und mit welchen Parametern:
              <pre><code>
expect(aMockFn).toHaveBeenCalled());  // Mock wurde aufgerufen (Parameter werden ignoriert)
expect(aMockFn).toHaveBeenCalledWith("hello", "world")); // Mock wurde mit 'huhu' aufgerufen
expect(aMockFn).toHaveBeenCalledTimes(1)); // Mock wurde genau einmal aufgerufen

// √úbergebene Paramter stehen √ºber .mock.calls:
expect(aMockFn.mock.calls[0][0]).toBe("hello");
expect(aMockFn.mock.calls[0][1]).toBe("world");
                      </code></pre>
            </li>
            <li>
              Implementierung der Mock-Funktion kann als Parameter √ºbergeben:
              <pre><code>
        const aMockFn = jest.fn( param => `Hello, ${param}` );
        
        console.log(aMockFn('World'));
        // => Hello, World
                  </code></pre>
            </li>
          </ul>
        </section>

        <section data-markdown>
          <textarea data-template>
### √úbung: Hello Jest!

* Im Workspace-Verzeichnis `blog-example/workspace-typescript` findest Du eine Datei `format-persons.ts`, die eine einzige Funktion enth√§lt.
* Schreibe f√ºr diese Funktion einen Test in `workspace-typescript/__tests__/format-persons.test.ts`
* Du kannst den Test mit `npm test -- format-person` ausf√ºhren
* Hinweise dazu findest Du in `format-persons.test.ts`
* Eine m√∂gliche L√∂sung findest Du in `blog-example/steps/6-tests/__tests__`
* Wenn Du fertig bist, bitte virtuell die Hand haben üôãüèª‚Äç‚ôÄÔ∏è  

        </textarea
          >
        </section>

        <section>
          <h3>Testen von React Komponenten</h3>
        </section>

        <section>
          <h3>react-testing-library</h3>
          <p>
            <em
              >"Simple and complete React DOM testing utilities that encourage good testing
              practices."
            </em>
          </p>

          <p>
            <a href="https://github.com/testing-library/react-testing-library" target="_blank"
              >https://github.com/testing-library/react-testing-library</a
            >)
          </p>
          <p>
            Philosophie: Tests werden aus User-Perspektive geschrieben. Das bedeutet, um die zu
            testenden Elemente zu finden, suchst Du nach Eigenschaften, nach denen auch ein User
            suchen w√ºrde (z.B. Labels, Placeholder etc.)
          </p>
          <p>üëâ <code>workspace-typescript</code></p>
        </section>
        <section>
          <h3>react-testing-library</h3>
          <p>Example</p>
          <pre><code class="javascript"  >
            import { render, screen } from "@testing-library/react";
            import userEvent from "@testing-library/user-event";

            it("invokes callback on button click", () => {
              const onAddPostFn = jest.fn();
            
              // Render
              render(&lt;PostList onAddPost={onAddPostFn} posts={mockPosts} />);
            
              // search the button
              const buttonElement = screen.getByRole("button", { name: "Add Post" });

              // "click" the button
              userEvent.click(buttonElement);
            
              // make sure it has been invoked
              expect(onAddPostFn).toHaveBeenCalled();
            });

            </code></pre>
        </section>

        <section>
          <h3>React Testing Library im Detail</h3>
        </section>

        <section>
          <h3>Die render-Funktion</h3>
          <ul>
            <li>
              Die render-Function aus der react-testing-library wird im Test verwendet, um eine
              React Komponente (ohne Browser) zu rendern
            </li>
            <li>Genauso wie in der Anwendungen k√∂nnen Properties angegeben werden</li>
            <li>
              <pre><code class="javascript"  >
import { render } from "@testing-library/react";
  
// Render a single component
render(&lt;PostList onAddPost={onAddPostFn} posts={mockPosts} />);
            </code></pre>
            </li>
            <li>
              Dran denken, ggf. Contexte ebenfalls zu erzeugen, falls diese ben√∂tigt werden (Router,
              Redux, GraphQL etc)!
            </li>
            <li>
              <pre><code class="javascript"  >

// Render with surrounding Redux Provider (or Router, your own Context etc.)
render(
  &lt;Provider>
    &lt;PostList onAddPost={onAddPostFn} posts={mockPosts} />
  &lt;/Provider>
);
            </code></pre>
            </li>
            <li>
              Mock Provider:
              <ul>
                <li>
                  <a href="https://reactrouter.com/en/main/router-components/memory-router"
                    >Memory Router</a
                  >
                </li>
                <li>
                  <a
                    href="https://www.apollographql.com/docs/react/development-testing/testing/#the-mockedprovider-component"
                    >Apollo MockedProvider</a
                  >
                </li>
              </ul>
            </li>
          </ul>
        </section>

        <!-- ######################################################################################### ########################## -->

        <section>
          <h3>"Snapshot Testing" mit Jest</h3>
          <p>
            <code>expect(obj).toMatchSnapshot()</code> vergleicht ein erzeugtes JSON-Objekt mit
            einem gespeicherten JSON-Objekt aus einer Datei:
          </p>
          <ul>
            <li>
              Bei der <b>ersten</b> Ausf√ºhrung: Snapshot-Datei wird angelegt (
              <a href="slides/images/jest-snapshot-file.png" target="_blank">Beispiel</a>)
              <ul>
                <li>Die Snapshot-Datei wird nun in Git eingecheckt</li>
              </ul>
            </li>
            <li>
              In den <b>folgenden</b> Test Ausf√ºhrungen: ein neuer Snapshot wird jeweils erzeugt und
              mit dem <b>gespeicherten</b> Snapshot verglichen
            </li>
            <li>
              Wenn die Snapshots nicht identisch sind:
              <ul>
                <li>
                  Fehler mit Unterschieden (<a
                    href="slides/images/jest-snapshot-diff.png"
                    target="_blank"
                    >Beispiel</a
                  >)
                </li>
                <li>
                  Im "watch mode" von Jest kann der Snapshot aktualisiert werden
                  <img src="slides/images/jest-snapshot-update.png" />
                </li>
              </ul>
            </li>
          </ul>
        </section>
        <section data-markdown>
          <textarea data-template>
### Snapshot Tests mit React

```typescript
  import { render } from "@testing-library/react";
          
  test('it should render correctly', () => {
      const mockPosts = [ /* ... */ ];

      const result = render(<PostList posts={mockPosts} onAddPost={jest.fn()} /> );
      
      expect(result.asFragment()).toMatchSnapshot();
  });  
```
            
          </textarea>
        </section>

        <!-- ######################### ########################### #################################################### -->
        <section>
          <h3>query Funktionen</h3>
          <p>
            Um die gerenderten HTML-Elemente aus deiner Komponente zu √ºberpr√ºfen und mit ihnen zu
            interagieren, musst Du sie ersteinmal finden ü§ì
          </p>
          <p>
            Auf dem globalen <b>screen</b> Objekt der Testing-Lib sind verschiedene Funktionen
            definiert, mit denen Du nach Elementen suchen kannst
          </p>
          <p>
            Die query-Funktionen haben unterschiedliche <b>Suffixe</b>, die beschreiben,
            <b>nach welchem Kriterium</b> Du suchst (nach Label, nach aria-role, ...)
          </p>
          <p>
            Die Funktionen haben au√üerdem jeweils einen <b>Pr√§fix</b> (getBy, queryBy etc) der
            beschreibt, die Art des R√ºckgabewerts der jeweilgen Funktion (z.B. ob sie einen Error
            wirft oder null zur√ºckgibt, wenn das angefragte Element nicht gefunden wurde)
          </p>
          <p>
            Mehr zu den query-Funktionen:
            <a
              target="_blank"
              href="https://testing-library.com/docs/react-testing-library/cheatsheet#queries"
              >React Testing Library Cheatsheet</a
            >
          </p>

          <pre><code class="javascript">
  // BEISPIELE: 

  // suche nach einem Button (Annahme: es gibt GENAU EINEN, ansonsten schl√§gt der Test fehl)
  const buttonElement = screen.getByRole("button", { name: "Add Post" });

  // suche nach einem Button (gibt null oder EINEN Button, wirft ansonst einen Fehler)
  const buttonElement = screen.queryByRole("button", { name: "Add Post" });

  // suche nach einem Button (gibt alle gefunden zur√ºck oder ein leeres Array)  
  const buttonElement = screen.queryAllByRole("button", { name: "Add Post" });
</code></pre>
        </section>

        <section>
          <h3>√úberpr√ºfen von Elementen</h3>
          <p>
            Wenn Du dein gesuchtes Elemente gefunden hast, kannst Du es √ºberpr√ºfen, ob es deinen
            Erwartungen entspricht (korrekte Attribute gesetzt etc.)
          </p>
          <p>
            Die Bibliothek
            <a href="https://github.com/testing-library/jest-dom" target="_blank">jest-dom</a> f√ºgt
            dazu DOM-spezifiche Matcher f√ºr Jest hinzu.
          </p>

          <pre><code class="javascript">
  import { screen } from "@testing-library/react";

  const buttonElement = screen.queryByRole("button", { name: "Add Post" });

  // stellt sicher, dass das Element im DOM vorhanden ist (getBy-Query w√ºrde hier vielleicht mehr Sinn machen)
  expect(buttonElement).toBeInTheDocument();

  // sicherstellen, dass ein Eingabefeld einen erwarteten Wert hat
  expect(titleInput).toHaveValue("Moin moin");

  // sicherstellen, dass ein Button disabled ist
  expect(okButton).toBeDisabled();
</code></pre>
          <p>Alle Matcher sind auf der oben verlinkten GitHub Seite dokumentiert</p>
        </section>
        <section>
          <h3>Interaktionen</h3>
          <p>
            Du kannst mit den Elementen interagieren, in dem Du ihnen Events sendest, genau wie es
            ein Browser tun w√ºrde
          </p>
          <p>
            Es gibt eine weitere Bibliothek,
            <a href="https://github.com/testing-library/user-event" target="_blank"> user-event</a>,
            die dir dabei hilft, die Events zu erzeugen.
          </p>

          <pre><code class="javascript">
            import userEvent from "@testing-library/user-event";
            // Simuliert die Eingabe in ein Textfeld
            userEvent.type(titleInput, "New Title");

            // Simuliert den Klick auf einen Button
            userEvent.click(clearButton);
          </code></pre>
          <p>Alle Events sind auf der GitHub Seite beschrieben (Link oben)</p>

          <p>
            Vor dem Versenden eines Events musst Du <b>nicht</b> √ºberpr√ºfen, ob das Element, dem Du
            das Event senden willst, vorhanden ist. Die Bibliothek gibt eine sehr sprechende
            Fehlermeldung aus, wenn das Element nicht vorhanden ist
          </p>
        </section>

        <section data-markdown>
          <textarea data-template>
## Der Testing Playground

* https://testing-playground.com/
* Hier kann man HTML-Code reinkopieren, mit dem man dann Query-Funktionen ausprobieren kann
* Dazu gibt es auch eine Browser-Erweiterung f√ºr [Chrome](https://chrome.google.com/webstore/detail/testing-playground/hejbmebodbijjdhflfknehhcgaklhano)
* Mit `screen.logTestingPlaygroundURL()` kann man eine URL ausgeben lassen, die den im Test gerenderten HTML-Code direkt im Playground √∂ffnet
          </textarea>
        </section>

        <section>
          <h2>√úbung: Ein Test f√ºr den PostEditor</h2>
        </section>

        <section>
          <h2>√úbung: Tests f√ºr den PostEditor</h2>
          <p>Erinnerung: Wir arbeiten in <code>blog-example/workspace-typescript</code></p>
          <p>Schritte:</p>
          <ol>
            <li class="fragment">
              Starte in <code>blog-example/workspace-typescript</code>:
              <code>npm test -- PostEditor</code> (der Prozess l√§uft "ewig")
            </li>
            <li class="fragment">
              Es sollte einen fehlerhaften Test geben:
              <b><code>PostEditor.test.tsx</code></b
              >.
            </li>
            <li class="fragment">Warum? Weil die Datei noch leer ist üò¨!</li>
            <li class="fragment">
              Implementiere Tests f√ºr die PostEditor-Komponente. In der Datei<b
                ><code>PostEditor.test.tsx</code></b
              >
              findest Du Vorschl√§ge.
            </li>
          </ol>
          <p class="fragment">
            Hinweis: wenn Du die Datei speicherst, werden die Tests automatisch neu ausgef√ºhrt
            (solange Du
            <code>npm test</code> noch laufen hast), ansonsten kannst Du "a" auf der Kommandozeile
            dr√ºcken, zum erneuten Ausf√ºhren der Tests.
          </p>
          <p class="fragment">M√∂gliche L√∂sungen in <code>steps/6-test</code></p>
          <p class="fragment">Wenn Du fertig bist, bitte "Hand heben" üôã‚Äç‚ôÄÔ∏è</p>
        </section>

        <section>
          <h3>Testen von fetch-Aufrufen</h3>
          <p>Herausforderungen:</p>
          <ul>
            <li>Asynchroner Code (nicht beschr√§nkt auf fetch)</li>
            <li>Server Zugriffe/Server Mocks</li>
          </ul>
        </section>
        <section>
          <h3>Behandlung von asynchronem code</h3>
        </section>

        <section>
          <h3>Testen von asynchronem Code</h3>
          <p>
            Beispiel: Die <b>App</b> Komponente l√§dt Daten, <em>erst dann</em> stellt sie die
            PostList dar. Das Laden der Posts ist asynchron.
          </p>

          <pre><code class="javascript">
            it("should render posts read from backend", () => {
              render(&lt;App />);
            
              // Annahme: es gibt einen Artikel mit dem Title "Learning React"
              const articleOne = screen.findByRole("heading", { name: "Learning React" });

              expect(articleOne).toBeInTheDocument(); // THIS WON'T WORK!
            });
          </code></pre>
          <p>
            Wir k√∂nnen einen Test als async-funktion schreiben und darin mit <b>await</b> auf ein
            Element warten
          </p>
          <pre><code class="javascript">
            // Test-Funktion als async-Funktion (beachte 'async'):
            it("should render posts read from backend", async () => {
              render(&lt;App />);
            
              // Beachte await hier:
              const articleOne = await screen.findByRole("heading", { name: "Learning React" });

              expect(articleOne).toBeInTheDocument(); // YIPPIE, WORKS
            });
          </code></pre>
          <p>
            Achtung! Ihr m√ºsst <code>find</code> Query-Funktionen verwenden, da die
            <code>get</code>-Funktionen davon ausgehen, dass ein Element bereits vorhanden ist, und
            nicht noch darauf warten.
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Testen von fetch</h3>
          <p>Wie gesehen, k√∂nnen wir asynchronen Code testen</p>
          <p>Wollen wir fetch-Aufrufe in unserem Code haben, den wir testen?</p>
          <p>
            M√∂glicherweise nicht, weil wir bei echten fetch-Aufrufen auch einen echten, laufenden
            und funktionierenden Server im Test br√§uchten
          </p>
          <p>Stattdessen wollen wir das "echte" fetch mocken</p>
        </section>

        <section>
          <h3>Fetch mocken, Ansatz #1</h3>
          <p>Wir k√∂nnen <b>komplette Module</b> in Jest mocken</p>
          <p>Wir k√∂nnten unseren fetch-Code in ein eigenes Modul schieben und das dann mocken</p>

          <pre><code class="javascript">
            // api.ts (fetch vereinfacht!)
            export function readPosts() {
              return fetch("http://localhost:7000/posts").then(response => response.json());
            }
          </code></pre>

          <pre><code class="javascript">
            // App.tsx:

            import { readPosts } from "./api";
            function App() {
              // ...
              React.useEffect(() => {
                // Verwenden von readPosts hier:
                readPosts()
                  .then(json => {
                    setLoading(false);
                    setPosts(json);
                  })
                  .catch(err => console.error("Loading data failed: " + err));
              }, []);
            }
          </code></pre>
        </section>
        <section>
          <h3>Mocken von Modulen in Jest</h3>
          <p>Es gibt mehrere Varianten. Das hier die einfachste(?)</p>

          <pre><code class="javascript">
            // App.test.tsx

            const mockPosts = [
              { id: "1", title: "One Fetch Mock", body: "Lorem ipsum" },
              { id: "2", title: "Second Post Fetch Mock", body: "Some more content" }
            ];

            jest.mock("../api", () => ({
              readPosts: () => Promise.resolve(mockPosts)
            }));

            it("should render posts read from backend", async () => {
              render(&lt;App />);
            
              // Hier immer noch asnychroner Code (deswegen await), aber:
              // kein laufender Server mehr ben√∂tigt
              const articleOne = await screen.findByRole("heading", { name: "One" });
              expect(articleOne).toBeInTheDocument();

              expect(screen.getByText("Second Post")).toBeInTheDocument();
            });
          </code></pre>
          <p>
            Beispiel:
            <code
              >blog-example/steps/6a-testing-with-api-module/src/__tests__/App_module_mock.test.tsx</code
            >
          </p>
        </section>
        <section>
          <h3>Ansatz #2: fetch API mocken</h3>
          <p>Es gibt mehrere Bibliothken mit fetch-Mocks</p>
          <p>
            F√ºr mich funktioniert
            <a href="https://www.npmjs.com/package/jest-fetch-mock" target="_blank"
              >jest-fetch-mock</a
            >
            am Besten
          </p>

          <pre><code class="javascript">
            // App.test.tsx
            it("should render posts read from backend", async () => {
              // setzen des Ergebnisses, das der n√§chste fetch-Aufruf zur√ºckliefern soll
              fetchMock.mockResponse(JSON.stringify(mockPosts));

              render(&lt;App />);
            
              // Immer noch asynchroner Code, aber kein "echter" fetch-Aufruf mehr,
              // zur√ºckgegeben wird das oben angegebene Ergebnis
              const articleOne = await screen.findByRole("heading", { name: "One Fetch Mock" });

              expect(articleOne).toBeInTheDocument();
            });

          </code></pre>
          <p>
            Beispiel:
            <code
              >blog-example/steps/6a-testing-with-api-module/src/__tests__/App_jest_mock.test.tsx</code
            >
          </p>
        </section>

        <section data-markdown>
          <textarea data-template>
### jest-fetch-mock

* `fetchMock.mockResponse`: Ersetzt *alle* Aufrufe mit dem √ºbergebenen Ergebnis
* `fetchMock.mockResponseOnce`: Ersetzt nur den n√§chsten Aufruf mit dem √ºbergebenen Ergebnis
* `fetchMock.mockResponses`: Ersetzt die n√§chsten X Aufrufe mit den √ºbergebenen Ergebnissen
* Alle Funktionen haben dieselbe Signatur:
  * Entweder ihr setzt direkt das Ergebnis, das zur√ºckgeliefert werden soll
  * Oder ihr gebt eine Callback-Funktion an, die ein `Promise` mit der gew√ºnschten Ergebnis zur√ºckliefert
* Wenn ihr das Ergebnis direkt setzt, k√∂nnt ihr zwei Parameter √ºbergeben:
  1. Den Body, der zur√ºckgeliefert werden soll Achtung! String kein Objekt! (ggf.`JSON.stringify()` verwenden)
  2. Ein Objekt mit init-Parametern, mit dem ihr z.B. den Status setzen k√∂nnt
  * siehe dazu [API Dokumentation der Response Funktion](https://developer.mozilla.org/en-US/docs/Web/API/Response/Response)
* ```
  const mockPosts = [ { title: "Hello", body: "World"} ];
  // liefert HTTP 200 OK zur√ºck f√ºr alle folgenden fetch-Aufrufe zur√ºck:
  fetchMock.mockResponse(JSON.stringify(mockPosts));
  ```
* ```
const mockResponse = { id: "100", title: "Hello", body: "World", createdAt: "2022-09-06"};
// liefert HTTP 201 CREATED f√ºr den n√§chsten fetch-Aufrufe zur√ºck:
fetchMock.mockResponse(JSON.stringify(mockResponse), { status: 201 });
```


          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Ansatz #3: Mock Service Worker (MSW)</h3>

          <p><a href="https://github.com/mswjs/msw" target="_blank">MSW</a></p>
          <p>
            MSW mockt echte Server-Aufrufe mit einem
            <a href="https://developer.mozilla.org/de/docs/Web/API/Service_Worker_API"
              >Service Worker</a
            >
          </p>
          <p>
            fetch-Aufrufe werden "richtig" ausgef√ºhrt, aber beantwortet von dem Service Worker Mock
          </p>

          <pre><code class="javascript">
            // PostList.test.js
            import { rest } from 'msw'
            import { setupServer } from 'msw/node'
            
            const server = setupServer(
              rest.get('/posts', (req, res, ctx) => {
                return res(ctx.json( mockPosts ))
              }),
            )

            test("it should render blog list", async () => {
              render(&lt;PostList />);
              // ...
            })
          </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
### √úbung: Ein "Integrationstest" f√ºr die Blog-Anwendung

* Die `App.test.txt` ist auch noch leer üò¢
* Schreibe einen Test daf√ºr, der einmal die Anwendung "durchklickt". Stelle sicher:
  * Die Postlist-Komponente wird initial mit einer Menge von mockPosts gerendert
  * Der `Add Post`-Button funktioniert und √∂ffnet den PostEditor.
  * Das Speichern funktioniert
  * Nach dem Speichern wird wieder die PostList angzeigt und der neue Post wird sichtbar
* Verwende zum Mocken der Request die `jest-fetch-mock`-Bibliothek
* In `App.test.tsx` findest Du weitere Hilfe.
* Ausf√ºhren des Tests: `npm test -- App`
* Achtung: Es gibt einen [Bug in der React Testing Library](https://github.com/testing-library/react-testing-library/issues/1051), der zu folgender Warnung auf der Konsole f√ºhrt:
  * Diese **act**-Warnung bitte ignorieren:
  * ```
    console.error
    Warning: An update to App inside a test was not wrapped in act(...).
    
    When testing, code that causes React state updates should be wrapped into act(...):
    
    act(() => {
      /* fire events that update state */
    });
    /* assert on the output */
    ```            
          </textarea>
        </section>

        <section>
          <h2>Browser Tests</h2>
          <p>H√§ufig eingesetzt:</p>
          <ul>
            <li>
              <a href="https://www.selenium.dev/">Selenium - The "classic"</a>
            </li>
            <li><a href="https://www.cypress.io/" target="_blank">Cypress</a></li>
            <li>
              <a href="https://devexpress.github.io/testcafe/" target="_blank">TestCafe</a> (mit
              Support f√ºr sehr viele Browser, u.a. auch den Cloud-Service
              <a href="https://www.browserstack.com/" target="_blank">BrowserStack</a>)
            </li>
            <li>
              <a href="https://playwright.dev/">Playwright</a> von Microsoft. Noch relativ neu,
              Hype-Kurve zeigt gerade steil nach oben.
            </li>

            <li>
              In TestCafe und Cypress werden die Tests in JavaScript/TypeScript geschrieben,
              Selenium und Playwright gibt's f√ºr mehrere Sprachen
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->

        <!-- ########################## GRAPHQL ######################################### -->
        <section id="t-apollo-react">
          <h1>GraphQL</h1>
          <h2>Clients mit Apollo React</h2>
        </section>
        <section data-markdown>
          <textarea data-template>
### Vorbereitung
* Bitte das Repository klonen: `git clone https://github.com/nilshartmann/react18-training`
* Das GraphQL Backend starten:
* ```bash
  cd blog-example/backend-graphql

  npm install 
  npm start
  ```
* GraphQL Explorer sollte auf [http://localhost:4000](http://localhost:4000) laufen
* Wir arbeiten dann im Verzeichnis `blog-example/workspace-graphql`
* Dort die Anwendung starten:
* ```bash
  cd blog-example/workspace-graphql

  npm install 
  npm start
  ```
* Anwendung sollte jetzt auf [http://localhost:3000](http://localhost:3000) laufen
        
  </textarea
          >
        </section>
        <section>
          <h3>Apollo Client</h3>
          <p>
            <a href="https://www.apollographql.com/docs/react/"
              >https://www.apollographql.com/docs/react/</a
            >
          </p>
          <p>React Hooks um mit GraphQL Services zu kommunizieren</p>
          <p>
            Stellt einen <b>globalen Cache</b> zur Verf√ºgung, um konsistente Daten in der ganzen
            Anwendung sicherzustellen
          </p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Apollo Client DevTools</h3>

          <p>Browser-Erweiterung, stellt z.B. den Inhalt des Caches dar</p>

          <ul>
            <li>
              <a
                href="https://chrome.google.com/webstore/detail/apollo-client-devtools/jdkknkkbebbapilgoeccciglkfbmbnfm"
                >Chrome</a
              >
            </li>
            <li>
              <a href="https://addons.mozilla.org/de/firefox/addon/apollo-developer-tools/"
                >Firefox</a
              >
            </li>
          </ul>
        </section>

        <section data-markdown>
          <textarea data-template>
### Apollo Client

* Das `ApolloClient`-Objekt ist unter anderem f√ºr den Netzwerkverkehr, den Cache
            und Fehlerbehandlung zust√§ndig
* Der `ApolloClient` ist React-unabh√§ngig und kann auch mit anderen JavaScript-Frameworks
            verwendet werden.
* ```javascript
  import ApolloClient from "apollo-client";

  const client = new ApolloClient({
    link: new HttpLink({uri: "http://localhost:4000"}),
    cache: new InMemoryCache()
  }};
  ```

---

### Link

* Mit einem `Link` wird beschrieben, wie Apollo die HTTP-Requests zum Server machen soll
  * Man kann zum Beispiel eigene HTTP Header hinzuf√ºgen
  * Auch die Konfiguration f√ºr Websockets f√ºr Subscriptions erfolgt dar√ºber
* F√ºr verschiedene Aufgaben gibt es verschiedene `Link`-Implementierungen, die
  hintereinander ausgef√ºhrt werden k√∂nnen

---

### Link

* Beispiel: Header f√ºr Authentifizierung
* ```javascript
  const authLink = setContext((_, { headers }) => {
    // get the authentication token from local storage if it exists
    const token = localStorage.getItem("publy.token");
    if (!token) {
      return headers;
    }
    // return the headers to the context so httpLink can read them
    return {
      headers: {
        ...headers,
        Authorization: `Bearer ${token}`,
      },
    };
  });
  ```

---
<!-- .slide: data-visibility="hidden" -->
### Subscriptions

* Um mit Subscriptions zu arbeiten, braucht man einen eigenen `Link`
  * "Regul√§re" Requests (f√ºr Queries und Mutations) m√ºssen an den HTTP-Endpunkt gehen
  * F√ºr Subscriptions m√ºssen die Requests √ºber das WS-Protokoll an den WS-Endpunkt gehen
* Es gibt einen eigenen Link daf√ºr: `GraphQLWsLink`
* ```javascript
  const wsLink = new GraphQLWsLink(
    createClient({
      url: "ws://localhost:8080",
    })
  );
  ```

---
<!-- .slide: data-visibility="hidden" -->
### Subscriptions

* Mit einem _Splitter_ kann ausgew√§hlt werden, mit welchem `Link` ein Request an den Server gesendet werden soll
* Damit k√∂nnen Subscriptions mit dem eigenen Websocket-Link ausgef√ºhrt werden
* ```javascript
  const wsLink = ...;
  const httpLink = ...;

  const remoteLink = split(
    // split based on operation type
    ({ query }) => {
      const def = getMainDefinition(query);
      return (
        def.kind === "OperationDefinition" && def.operation === "subscription"
      );
    },
    wsLink,
    httpLink
  );
  ```

---
<!-- .slide: data-visibility="hidden" -->
### Links

* Die Links werden beim erzeugen des Apollo Clients aneinander geh√§ngt
* ```javascript
  const authLink = ...;
  const remoteLink = new HttpLink(...);
  const client = new ApolloClient({
    link: ApolloLink.from([authLink, remoteLink]),
    cache: new InMemoryCache()
  });
```


          </textarea>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Apollo React Client</h3>
          <p>
            Die Komponenten bzw. die React-spezifische API des Apollo Clients, ben√∂tigt Zugriff auf
            den ApolloClient
          </p>
          <p>Das Client-Objekt muss der Anwendung bereitgestellt werden</p>
          <p>
            Dazu wird die <code>ApolloProvider</code>-Komponente verwendet, die allen
            darunterliegenden Komponenten Zugriff auf den ApolloClient erm√∂glicht:
          </p>

          <pre class="fragment"><code class="javascript">
import { ApolloProvider } from "@apollo/client";

const client = ...;

const root = ReactDOM.createRoot(document.getElementById("root"));

root.render(
    &lt;ApolloProvider client={client}>
      &lt;App />
    &lt;ApolloProvider>
  );
</code></pre>
          <p class="fragment">
            (Der Apollo Client verwendet intern die
            <a ref="https://reactjs.org/docs/context.html">React Context API</a>)
          </p>
        </section>
        <section>
          <h3>Apollo GraphQL Client in React</h3>
          <p>Live: workspace-graphql</p>
          <p>üëâ PostListPage.tsx mit <b>useQuery</b></p>
        </section>
        <section data-markdown="">
          <textarea data-template>
### GraphQL Operationen beschreiben

* GraphQL Operationen k√∂nnen inline oder in einer eigenen Datei beschrieben werden
* Inline: mit der `gql` [Tagged Template Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates) direkt im Code
* Die `gql`-Funktion erzeugt ein **GraphQL Document Object**, das die geparste Operation enth√§lt
    * Dieses Objekt verwenden wir zum Ausf√ºhren der Operation
* ```javascript
  import { gql } from "@apollo/client";

  const PostListPageQuery = gql`
    query PostListPageQuery {
      posts {
        id
        title
        teaser(maxLength: 20)
        date
      }
    }
  `;
  ```
* Um die GraphQL-Operationen in einer eigenen Datei abzulegen und zu importieren, m√ºsst ihr [Euer Setup anpassen](https://create-react-app.dev/docs/loading-graphql-files/)
  * Wenn ihr mit dem [GraphQL Codegenerator](https://www.graphql-code-generator.com/) arbeitet, braucht ihr das _nicht_


---

### Verwenden des Apollo React Clients
* Apollo stellt f√ºr die drei GraphQL Operationstypen jeweils eigene
              Hooks zur Verf√ºgung:
  * [useQuery](https://www.apollographql.com/docs/react/data/queries/#usequery-api) bzw. [useLazyQuery](https://www.apollographql.com/docs/react/data/queries/#manual-execution-with-uselazyquery)
  * [useMutation](https://www.apollographql.com/docs/react/data/mutations/#usemutation-api)
  * [useSubscription](https://www.apollographql.com/docs/react/data/subscriptions/#usesubscription-api-reference)
* Die Hooks funktionieren alle √§hnlich:
  * Sie erwarten ein Dokument mit einer GraphQL Operation (Ergebnis von `gql`)
  * Verhalten kann mit weiteren Argumenten konfiguriert werden, z.B. Setzen von Variablen
  * Der R√ºckgabetyp ist ein Objekt mit Informationen √ºber den Request (loading, data, error). Bei
    `useMutation` kommt kommt au√üerdem eine Funktion zum Ausf√ºhren der Mutation zur√ºck

---

### useQuery: GraphQL Query ausf√ºhren
<!-- .slide: class="left" -->
* Der `useQuery`-Hook f√ºhrt einen GraphQL aus:
* ```typescript
  const PostListPageQuery = gql`...`;
  function PostListPage() {
    const { loading, error, data } = useQuery(PostListPageQuery);

    if (loading) {
      return <h1>Loading, please wait...</h1>;
    }

    if (error) {
      return <h1>GraphQL Failed: {error.toString()}</h1>;
    }

    return &lt;PostList posts={data.posts} />;
  }
  ```
---

### useQuery - Lebenszyklus
* `useQuery` f√ºhrt den √ºbergebenen Query automatisch aus, sobald die Komponente _gemounted_ wurde
* Sobald der Request l√§uft, gibt die Funktion ein Objekt zur√ºck, in dem `loading` auf `true` gesetzt ist. Damit kannst Du z.B. einen Loading Indikator anzeigen
* Sobald die Antwort des Queries ankommt, wird deine Komponente erneut gerendert
  * Der useQuery-Hook gibt nun ein Objekt zur√ºck, in dem entweder <code>error</code> oder
              `data` gesetzt ist und `loading` nun `false` ist.
  * Du kannst die Informationen nutzen, um die Darstellung zu aktualisieren
  * Wenn der Request erfolgreich war, aktualisiert Apollo den globalen Cache mit den
              geladenen Daten
  * _Alle_ sichtbaren Komponenten, die (Teile der) geladenen Daten darstellen,
              werden automatisch aktualisiert

---

### useQuery: Variablen
* GraphQL Queries k√∂nnen Variablen enthalten
* Das (optionale) zweite Argument von `useQuery` ist ein Objekt mit Konfigurationsoptionen
* Mit diesem Argument kannst Du Variablen an deinen Query √ºbergeben
* ```graphql
  const PostPageQuery = gql`
    query PostPage($postId: ID!) {
      post(postId: $postId) {
      id title date body
      user { name }
    }
  }
  
  `;
  ```
* ```typescript
  function PostPage() {
    // Example: Receive postId from URL params
    const { postId } = useParams();

    const { loading, error, data } = useQuery(PostPageQuery,
      {
        variables: { postId }
      }
    );
    // ...
  }
  ```
---
### Apollo Hooks mit TypeScript
* Die Apollo Hooks k√∂nnen mit Typ-Parametern typsicher gemacht werden.
* In der Regel k√∂nnen zwei Parameter angegeben werden:
  * `TData`: beschreibt, wie die gelesenen Daten aussehen (`data`-Knoten)
  * `TVariables`: beschreibt, ob/wie ben√∂tigte Variablen aussehen
* ```typescript
  const PostPageQuery = gql`...`;

  type IPostPageQuery = {
    id: String, title: String, date: string, body: string, user: { name: string } }
  }

  type PostPageVariables = { postId: string }

  function PostPage({postId}: {postId: string}) {
    const result = useQuery<PostPageQuery, PostPageVariables>({
            variables: { postId });

    result.data?.id; // OK
    result.data?.content; // ERROR content not in data
    // ...
  }
  ```
---
### Das data-Field  
* Das `data`-Field enth√§lt im Erfolgsfall die geladenenen Daten
* Das `data`-Field ist in TypeScript aber _immer_ optional (`TData | undefined`), da es
  im Fehlerfall nicht gesendet wird, und in GraphQL Fehler und/oder Daten kommen k√∂nnen.
* Deswegen vor der Verwendung pr√ºfen:  
  * ```typescript
    const {data} = useQuery<...>();

    data.story.id; // ERROR: data might be undefined
    if (!data) {
      return <h1>No Data!</h1>;
    }
    data.story.id; // OK
    ```
* Alternativ: eine TypeScript Type-Assertion-Funktion bauen:
  * ```typescript
    function assertData<T>(t: T): asserts t is NonNullable<T> {
      if (!t) {
        throw new Error("Data not defined");
      }
    }

    // In der Komponente:
    const { data, loading, error } = useQuery<...>();
    // data hier TData | undefined

    if (loading) { ... }
    if (error) { ... }

    assertData(data);

    // data hier TData
    ```
---
### √úbung: Query ausf√ºhren

* Wir arbeiten im Verzeichnis `blog-example/workspace-graphql`
* Die `PostListPage` soll eine Liste von Post Teasern anzeigen
* Erg√§nze in `src/PostListPage.tsx` den dazu notwendigen Code
* In der Datei findest Du TODOs mit weiteren Informationen
* Eine m√∂gliche L√∂sung findest Du in der Datei <code>PostListPage<b>_useQuery.txt</b></code> in `steps/30-graphql-with-typescript`
* Wenn ihr fertig seid, bitte Hand in Zoom heben ü§ö

---
### TypeScript Code generieren
* <!-- .element: class="demo" --> PostListPage Query mit generierten Hooks
* Das Project [GraphQL Code Generator](https://www.the-guild.dev/graphql/codegen) bietet Code Generatoren f√ºr eine Reihe von GraphQL Frameworks, u.a. Apollo/React
* Generiert werden k√∂nnen damit:
  * Typen f√ºr das Query-Ergebnis (`TData`)
  * Variablen (`TVariables`)
  * Typen f√ºr verwendete Fragmente
  * Fertige Hook-Funktionen

---
### Code Generator: Konfiguration
* Je nach Konfiguration sucht der Generator nach `.graphql`-Dateien mit Queries und/oder `gql`-Funktionen
* Die Typen werden in eine Datei (z.B. `generated.tsx`) geschrieben
* Der Generator braucht Zugriff auf das Schema (lokal oder remote)
* Der Generator kann im watch-Modus betrieben werden, dann wird automatisch neu generiert, wenn neue Queries geschrieben werden
* ```yml
  overwrite: true
  schema:
    # Remote Schema:
    - "http://localhost:4000/graphql"
    # ...oder aus lokaler JS, TS, GraphQL oder JSON-Datei:
    - "../../backend-graphql/src/schema.js"
  # In welchen Dateien soll nach GraphQL Queries gesucht werden?
  documents: "./src/**/{*.graphql,*.tsx}"
  # Was (und wohin) soll generiert werden:
  generates:
    src/generated/graphql.tsx:
      plugins:
        - "typescript"
        - "typescript-operations"
        - "typescript-react-apollo"
```
* Empfehlung: Code Generator auch im CI Build ausf√ºhren lassen!

---
### Code Generator
* _Empfehlung_: Typen und Hooks generieren lassen
* Die generierten Hooks sind "nur" Wrapper-Funktionen um `useQuery`, `useMutation`, ersparen
  aber das hinschreiben der Typ-Informationen und des Dokuments mit dem Query
* ```typescript
  function PostPage({postId}: {postId: string}) {

    // useQuery von Hand:
    const { data } = useQuery<IStoryPageQuery, PostPageQueryVariables>(
            PostPageQuery, { variables: { postId } });

    // generierter Hook:
    const { data } = usePostPageQuery({ variables: { postId } });

    // data-Objekte in beiden F√§llen gleich
    // ...
  }
  ```
---
### Code Generator: Fragmente
* * <!-- .element: class="demo" --> Beispiel: PostListPage fragt auch User ab
* F√ºr verwendete Fragmente wird ein eigener TypeScript-Typ generiert, das kann praktisch
  sein, wenn man Typen f√ºr Teile eines Queries ben√∂tigt.
* Beispiel:
* ```graphql
  query { posts { user { id name } } }
```
* Generierter Typ (konzeptionell):
* ```typescript
  type PostsQuery = { posts: Array<{ user: { id: string, name: string } }> }
  ```
* Um nur den Typen f√ºr den User zu ermitteln (z.B. um in einer Komponente als Property zu verwenden),
 kann man schreiben:
* ```javascript
  type UserType = PostsQuery["posts"][0]["user"]; // ü§Ø üò±
  ```
* Einfacher mit einem Fragment:
* ```graphql
  fragment UserFragment on User { id name }
  query { stories { user { ...UserFragment } } }
  ```
* Nun wird ein `UserFragment`-Typ generiert:
* ```typescript
  type UserFragment = { id: string, name: string }; // üòä
  ```
---
### √úbung: Queries mit dem Codegenerator

* Stelle die `PostListPage`-Komponente auf den generierte Query-Hook um
* Im Workspace ist der Codegenerator installiert und eingerichtet
* Die Hook-Funktionen sind auch schon generiert
* Ersetze in der `PostListPage`-Komponente den `useQuery`-Aufruf durch den generierten Hook
* Eine L√∂sung findest Du in `steps/30-graphql-with-typescript`

---
### useQuery: Caching
* Wenn deine Komponente erneut gerendert wird, wird dein Query
            **nicht erneut ausgef√ºhrt**, sofern Apollo das Ergebnis noch im Cache findet
* <!-- .element: class="demo" -->Netzwerk-Tab
* <!-- .element: class="demo" -->Zwischen Einzel-Ansichten wechseln
---

### Der Apollo Cache
* Apollo _normalisiert_ die Daten bevor sie in den Cache gelegt werden:
* F√ºr jedes Objekt, das als Teil deines Queries geladen wurde (egal auf welchem Level),
            Apollo ermittelt den **typename** (`__typename`-Feld)
  * Das `__typename`-Feld wird daf√ºr automatisch allen Queries von Euch
            hinzugef√ºgt!
* F√ºr jedes Objekt extrahiert Apollo dessen `id`
  * Wenn das `id`-Feld eines Objektes nicht `id` hei√üt, muss das in der
            Konfiguration von Apollo gesetzt werden
  * **Empfehlung:** *Immer* das `id`-Feld in jedem Objekt in jedem Query
            abfragen!
* Achtung! Listen werden *nicht* aktualisiert, bzw. nicht erweitert/gek√ºrzt
---

### Der Apollo Cache: Aktualisierung
* Es gibt mehrere M√∂glichkeiten, den Cache zu aktualisieren:
  * [Refetch Function](https://www.apollographql.com/docs/react/data/queries/#refetching)
  * [Fetch Policy](https://www.apollographql.com/docs/react/data/queries/#setting-a-fetch-policy)
  * [Polling](https://www.apollographql.com/docs/react/data/queries/#polling)
  * F√ºr Paginierung von Listen mit der [Fetch more](https://www.apollographql.com/docs/react/pagination/core-api/#the-fetchmore-function)-Funktion
  * [Per Subscription](https://www.apollographql.com/docs/react/data/subscriptions/#subscribing-to-updates-for-a-query)
* Nach dem Ausf√ºhren einer Mutation...  
  * ...direkt mit der [Cache API](https://www.apollographql.com/docs/react/data/mutations/#updating-the-cache-directly)
  * ...mit [refetchQueries](https://www.apollographql.com/docs/react/data/mutations/#refetching-queries)

---
### Refetch Funktion
* `useQuery` liefert eine **refetch**-Funktion, die Du verwenden kannst, um
            den Query erneut auszuf√ºhren (z.B. nach Klick auf einen "Aktualisieren"-Button)
* Bei Bedarf kannst Du der `refetch`-Funktion neue Variablen √ºbergeben
  * Zum Beispiel um eine weitere Seite eines Such-Ergebnisses zu laden
* ```javascript
  function PostListPage() {
    const { loading, error, data, refetch } = usePostListPageQuery();

    if (loading) {
      return <h1>Loading, please wait...</h1>;
    }

    if (error) {
      return <h1>GraphQL Failed: {error.toString()}</h1>;
    }

    return <PostList posts={data.posts} onRefetch={refetch} />;
  }

  function PostList({posts, onRefetch}) {
    return <div>
      <button onClick={onRefetch}>Refresh</button>
      ...
    </div>
  }
  ```
---
### Fetch Policy
* <!-- .element: class="demo" --> `fetchPolicy` f√ºr `PostList` einstellen (`network-only`)
* Mit einer Fetch Policy kannst Du bei `useQuery` einstellen, wann dein Query
            erneut ausgef√ºhrt werden soll
  * **cache-first**: Wenn die angeforderten Daten bereits im Cache sind, werden sie aus
              dem Cache zur√ºckgegeben, sonst vom Backend geladen (Default)
  * **cache-and-network**: Falls vorhanden, Daten aus dem Cache zur√ºckgeben, aber in
              jedem Fall auch einen Backend-Request auszuf√ºhren, um ggf. aktualisierte Daten zu
              laden (Schnelle Darstellung, die ggf. kurze Zeit sp√§ter aktualisiert wird)
  * **network-only**: Immer Daten vom Backend laden (keine Daten vom Cache verwenden),
              aber mit dem Ergebnis den Cache aktualisieren
  * **no-cache**: Immer Daten vom Backend laden und auch nicht den Cache aktualisieren
  * **cache-only**: Nur Daten vom Cache verwenden. Wenn die Daten darin nicht gefunden
              werden, wird kein Ergebnis zur√ºckgeliefert
---

### Fetch Policy: Beispiel
<!-- .slide: class="left" -->
* ```javascript
  function PostPage() {
    const { postId } = useParams();

    const { loading, error, data } = useQuery(PostPageQuery,
      {
        variables: { postId },
        fetchPolicy: "network-only"
      }
    );
    // ...
  }
  ```
---
### Polling
* Du kannst ein `pollInterval` (Zeit in ms) als Query Option angeben. Apollo
            f√ºhrt dann den Query dann in dem angegebenen Interval automatisch neu aus und aktualisiert den Cache mit den gelesenen Daten
* ```javascript
  function PostListPage() {
    const { loading, error, data } = useQuery(PostListPageQuery,
      { pollInterval: 1500 }
    );

    // bzw:
    const { loading, error, data } = usePostListPageQuery(
      { pollInterval: 1500 }
    );

    // ...wie gesehen...
  }
  ```
---


### Apollo GraphQL: Mutations
<!-- .slide: class="left" -->

* Ausf√ºhren von Mutations ist √§hnlich wie das Ausf√ºhren eines Queries
* Hook: [useMutation](https://www.apollographql.com/docs/react/data/mutations/#executing-a-mutation)
* Der `useMutation` Hook gibt ein Array (Tuple) mit zwei Eintr√§gen zur√ºck:
  1. Eine Funktion zum Ausf√ºhren der Mutation (z.B. nach einer Benutzerinteraktion)
  2. Das Ergebnis-Objekt, das wir schon bei `useQuery` gesehen haben
            (zus√§tzlich: ein `called`-Property, das angibt, ob die Mutation bereits mind. einmal ausgef√ºhrt wurde)
* ```jsx
  function PostEditorPage() {
    const [mutate, { error, data, called }] = useMutation<IAddPostMutation, IAddPostVariables>
            (AddPostMutation);

    // oder generiert:
    const [mutate, { error, data, called }] = useAddPostMutation();

    function addPost(postInput: {title: string, body: string} ) {
      // Verwendung von mutate hier Typsicher, da TS
      // das 'variables'-Objekt von useMutation kennt
      mutate({
          variables: { input: postInput }
      });
    }

    const errorMessage = error ? ... : null;

    if (called && !errorMessage) {
      // Mutation has been executed and was successful
      return &lt;SuccessConfirmation />;
    }

    // Mutation hasn't been run or failed with an error
    return <PostEditor errorMessage={errorMessage} />
  }
  ```
---

### Die mutate-Funktion

* Der `mutate`-Funktion k√∂nnen (fast) alle Argumente √ºbergeben werden, die
  auch an `useMutation` √ºbergeben werden k√∂nnen (insb. Variablen)
* Beim Aufruf der `mutate`-Funktion wird die Mutation ausgel√∂st und die Komponente
  wird mit neuen Ergebnissen (oder Fehlern) neu gerendert (wie bei `useQuery`)
* Die `mutate`-Funktion liefert ein Promise zur√ºck, das mit dem Ergebnis
  der Mutation (`data` oder `errors`) aufgel√∂st wird, sobald das Ergebnis da ist
* Damit kannst Du weitere Logik unmittelbar nach dem Abschluss der Mutation ausf√ºhren
* ```jsx
  function PostEditorPage({onPostSaved}: {onPostSaved: () => void}) {
    const [mutate, { error, data, called }] = useAddPostMutation();

    async function addPost(postInput: {title: string, body: string}) {
      const {data, error} = mutate({
          variables: { input: postInput }
      });

      if (data) {
        // Beispiel: Alles OK, jetzt Redirect machen
        history.push("/...");
        // ...oder Callback von Oberkomponente aufrufen:
        onPostSaved();
      }
    }
  ```

---
### Nach einer Mutation... wird der Cache automatisch aktualisiert (eventuell)
* Wenn deine Mutation ein Objekt zur√ºckliefert, das sich bereits im Cache befindet, wird
            es dort aktualisiert
* PostPage, Like vergeben <!-- .element: class="demo" -->             
* Beispiel: Du *aktualisierst* eine existierende Story und das Ergebnis der
            Mutation enth√§lt irgendwo die aktualisierte Story (zumindest die aktualisierten Teile).
  * Voraussetzung: im Ergebnis kommt auch die `id` der Story vor
* ```javascript
  const LikePostMutation = gql`
    mutation {
      likePost(postId: "P1") {
          id
          likes
      }
    }
  ```
* In diesem Beispiel kann Apollo das Objekt <b>P1</b> im Cache automatisch aktualisieren
  (neue Anzahl von likes)

---
### Den Cache nach einer Mutation aktualisieren
* Mit [refetch Queries](https://www.apollographql.com/docs/react/data/mutations/#refetching-queries) kannst Du eine Liste von Queries angeben, die erneut ausgef√ºhrt werden, wenn
              eine Mutation erfolgreich war

* ```typescript
  import { useAddBlogPostMutation, PostListPageDocument } from "./generated/graphql";


  async function savePost(post: NewBlogPost) {
    const { data } = await mutate({
      variables: { postData: post },
      refetchQueries: [
        {
          query: PostListPageDocument
        }
      ]
    });
  }
  ```
* Mit der [update Function](https://www.apollographql.com/docs/react/data/mutations/#updating-the-cache-directly) kannst Du den Cache direkt per API manipulieren, sobald deine Mutation erfolgreich
              war

---
### √úbung: eine Mutation
* Die Logik zum Anlegen eines BlogPosts implementieren
* Die Mutation (`AddBlogPostMutation`) ist schon fertig und der Code daf√ºr generiert
* In `PostEditorPage` musst Du den Code vervollst√§ndigen, siehe dort f√ºr weitere Informationen
* Was musst du tun, damit der neu gespeicherte Blog Post auch in der Liste auf der ersten Seite angezeigt wird?
* M√∂gliche L√∂sung in `steps/9_graphql-with-typescript`

</textarea
          >
        </section>

        <section id="t-apollo-react-deep-dive">
          <h1>Apollo React Client</h1>
          <h2>Deep dive</h2>
        </section>
        <section data-markdown>
          <textarea data-template>
### Vorbereitung
* Bitte das Repository klonen: `git clone https://github.com/nilshartmann/react18-training`
* Das GraphQL Backend starten:
* ```bash
  cd blog-example/backend-graphql

  npm install 
  npm start
  ```
* GraphQL Explorer sollte auf [http://localhost:4000](http://localhost:4000) laufen
* Wir arbeiten dann im Verzeichnis `blog-example/workspace-graphql-advanced`
* Dort die Anwendung starten:
* ```bash
  cd blog-example/workspace-graphql-advanced

  npm install 
  npm start
  ```
* Anwendung sollte jetzt auf [http://localhost:3000](http://localhost:3000) laufen
        
  </textarea
          >
        </section>
        <section data-markdown>
          <textarea data-template>

### Testen von GraphQL Clients

* Wenn ihr GraphQL Anwendungen testen wollt, m√ºsst ihr m√∂glicherweise den Netzwerkverkehr mocken
* Dazu k√∂nnt ihr die besprochenen Techniken verwenden (jest-fetch-mock, msw, etc.)
* Alternativ: [MockedProvider](https://www.apollographql.com/docs/react/development-testing/testing) von GraphQL
* Damit k√∂nnt ihr Ergebnisse von Queries setzen
* Der Apollo Client liefert dann die Mock-Ergebnisse zur√ºck und f√ºhrt keine Netzwerkanfragen aus
* üßë‚Äçüíª Beispiel: Test f√ºr PostListPage
* ```typescript
  test("rendering works", () => {
    render(
        <MockedProvider mocks={[mock]}>
          <PostListPage />
        </MockedProvider>
    );
  })
  ```

---

### MockResponse

* Dem `MockedProvider` √ºbergebt ihr eine Liste mit `mocks`
* Das sind `MockResponse`-Objekte, die aus zwei Properties bestehen:
  * `request`: Gibt an, f√ºr welchen GraphQL Request die Antwort zur√ºckgeliefert werden soll
    * Ihr k√∂nnt einen Query angeben (Achtung! Der muss genau dem Query in Eurer Anwendung entsprechen!)
    * Ihr k√∂nnt zus√§tzlich Variablen f√ºr den Query angeben, die Eure Anwendung √ºbergibt
  * `result`: Enth√§lt die typischen Ergebnisse einer GraphQL Operation: entweder `data` oder eine Liste mit `GraphQLError`-Objekten (`errors`)-Knoten
* Der `MockResponse`-Typ in TypeScript ist typisiert, so dass ihr dort als Typ-Parameter den generierten Query-Typen angeben kann
* Dann ist zumindest das `result`-Feld typsicher

---
### MockResponse: Beispiel f√ºr data

```typescript
  const mock: MockedResponse<PostListPageQuery> = {
    request: {
      query: PostListPageDocument,
      operationName: "PostListPage"
    },
    result: {
      data: {
        posts: [
          {
            date: "2022-02-23",
            title: "Hello World",
            teaser: "Lorem ipsum",
            id: "P1"
          }
        ]
      }
    }
  };

  test("rendering works", async () => {
    render(
        <MockedProvider mocks={[mock]}>
          <PostListPage />
        </MockedProvider>
      );
      // Loading Indicator ist sofort sichtbar:
      expect(screen.getByRole("heading", {name: /please wait/i})).toBeInTheDocument();
    
      // Achtung Asynchron:
      expect(await screen.findByRole("heading", {name: /hello world/i})).toBeInTheDocument();
  });
```
---
### MockResponse: Beispiel f√ºr error

```typescript
const mock: MockedResponse<PostListPageQuery> = {
  request: {
    query: PostListPageDocument,
    operationName: "PostListPage"
  },
  result: {
    errors: [new GraphQLError("au weia!")]
  }
};

// Verwendung wie gesehen
```

---
### √úbung: GraphQL Requests testen

* In `PostPage.test.tsx` gibt es zwei Testf√§lle, die fertig implementiert werden m√ºssen!
* Du musst dort die Mocks korrekt definieren, ein Anfang findest Du dort bereits
* Der generierte TypeScript-Typ der Queries ist `PostPageQuery`.
* Tipp: mit TypeScript oder im Netzwerk-Tab der laufenden Anwendung pr√ºfen, wie die Daten aussehen, die zur√ºckgegeben werden m√ºssen.
* Du kannst die Tests ausf√ºhren mit: `npm test -- PostPage`
* Eine m√∂gliche L√∂sung findest Du in `steps/30-graphql-with-typescript/src/__tests__`
* Wenn Du fertig bist, bitte Hand heben! üôãüèª‚Äç‚ôÄÔ∏è
            
---
### Wiederholung:
## Der Apollo Cache


* <!-- .element: class="demo" --> Apollo Dev Tools mit fertiger Anwendung (`35-graphql-advanced`)
* <!-- .element: class="demo" --> Einzelne Artikel anzeigen
* <!-- .element: class="demo" --> "Like" vergeben

---


### Aktualisieren von Listen
* Wenn neue Daten f√ºr eine Liste geladen werden (oder welche entfernt werden),
  wei√ü Apollo nicht, wie damit umzugehen ist
* Der Cache kann dann nicht automatisch aktualisiert werden
* Beispiel:
  * Nach dem PostEditor wird der neue Post nicht auf der PostListPage angzeigt
  * <!-- .element: class="demo" --> Zeigen, was passiert, wenn refetchQueries entfernt wird
  * Zus√§tzliche Posts werden auf der PostList gelesen (z.B. Button "Mehr laden")
  * M√ºssen die neuen/zus√§tzlichen Posts am Anfang oder Ende der bestehenden Liste eingef√ºgt werden?
  * Sollen sie dort √ºberhaupt eingef√ºgt werden?

---
<!-- .slide: data-visibility="hidden" -->
### Aktualisieren von Listen
* Grunds√§tzlich k√∂nnen Listen mit verschiedenen Strategien aktualisiert werden:
  * **update**: Nach einer Mutation, die ein neues Objekte erzeugt (oder l√∂scht), soll das Objekt
  in eine Liste hinzugef√ºgt (oder gel√∂scht) werden
    * Sehen wir uns gleich exemplarisch an
  * **fetch more**: Jemand klickt z.B. auf "Weitere Eintr√§ge laden"-Link
    * Beispiel: Liste von Posts in PostList-Page
  * **subscription**: Eine Subscription liefert neue Elemente, die (auch) in eine bestehende Liste eingef√ºgt werden
* In jedem Fall m√ºssen wir dazu implementieren, *wie* die neuen Daten in die gecachten Listen kommen
### Die Apollo Cache API
* Du kannst den Query auslesen (mit einem GraphQL Query!)
* Du kannst den Cache direkt modifizieren, zum Beispiel Objekte hinzuf√ºgen und l√∂schen
* ü´£ Ich bin kein gro√üer Freund der Cache API, finde sie sehr verwirrend und √ºbersichtlich und versuche deren Benutzung zu vermeiden, wenn es irgendwie geht
* <!-- .element: class="demo" --> Implementieren in `PostEditorPage` (`workspace-graphql-advanced`)

---

### Das Apollo Cache Objekt
* Das `Cache`-Objekt bietet Funktionen zum Zugriff auf den Cache
* Das Objekt erh√§ltst Du zum Beispiel √ºber den `Client` oder als Argument in verschiedenen Callback-Funktionen
* Du kannst Daten aus dem Cache lesen, in dem Du die `readQuery`-Funktion verwendest, die ein GraphQL Query(!) erwartet
  * ```javascript
    const ReadPostsFromCache = gql`{ posts { id } }`;

    const posts = cache.read({query: ReadPostsFromCache});
    ```
* Der `read`-Funktion kannst Du einen Typ-Parameter mit dem Ergebnis des Queries angeben
  * ```javascript
    const ReadPostsFromCache = gql`{ posts { id } }`;

    const posts = cache.read<{ posts: Array<{id: string}>}>({query: ReadPostsFromCache});
    ```
* Mit `writeQuery` kannst Du neue Daten setzen. Dazu gibts Du einen Query an und die neuen Daten daf√ºr. Apollo mergt die dann im Cache zusammen:
* ```javascript
    const posts = cache.read({query: ReadPostsFromCache});
    const newPosts = [...posts, { id: "P1000", title: "..." } ];

    cache.write({
      query: ReadPostsFromCache,
      data: newPosts
    })
  ```
* `readFragment`/`writeFragment` und `modifiy` gibt es weitere M√∂glichkeiten [zur Interaktion mit dem Cache](https://www.apollographql.com/docs/react/caching/cache-interaction)
  * Diese k√∂nnen insbesondere besser geeignet sein, wenn Objekte modifziert werden sollen, die tiefer verschachtelt sind

---
### Cache nach einer Mutation aktualisieren
* Mit der `update`-Function von `useMutation` kannst Du den Cache direkt ver√§ndern
* Diese Funktion wird nach dem Ausf√ºhren der Mutation von Apollo aufgerufen
  * Achtung! Die Funktion wird auch aufgerufen, wenn die Mutation fehlgeschlagen ist
* Die Funktion bekommt zwei Parameter √ºbergeben:
  1. Das `cache`-Objekt
  2. Ein Objekt, mit der Antwort der Mutation (`data` und `errors`)

* ```javascript
  const ReadPostsFromCache = gql`{ posts { id } }`;

  function PostEditorPage() {
    function savePost(newPost) {
      mutate({
        variables: {...},
        update: (cache, { data, errors }) => {
          const existingPosts = cache.readQuery(...);

          // Liste mit neuen Daten erzeugen
          const newPosts = [data.newPost, ...existingPosts];

          // Daten schreiben
          cache.writeQuery({
            query: ReadPostsFromCache,
            data: { posts:  newPosts }
          });
      })
    }

    return ...;
  }
  ```
---
### Cache nach einer Mutation aktualisieren
<!-- .slide: class="left" -->
* Vollst√§ndiges Beispiel mit TypeScript und Pr√ºfungen
* ```javascript
  const ReadPostsFromCache = gql`{ posts { id } }`;

  function PostEditorPage() {
    function savePost(newPost) {
      mutate({
        variables: {...},
        update: (cache, {data}) => {
          if (!data) { return; }
          const newBlogPost = data.newPost.blogPost;

          const existingPosts = cache.readQuery<{ posts: Array<{ id: string }> }>({
            query: ReadPostsFromCache
          });

          const newPosts = existingPosts ? [newBlogPost, ...existingPosts.posts] : [newBlogPost];
          
          cache.writeQuery({
            query: ReadPostsFromCache,
            data: { posts: [data.newPost, ...existingPosts] }
          });
      })
    }

    return ...;
  }
  ``` 

---
### Aktualisieren von Listen: Pagination mit fetchMore
<!-- .slide: data-visibility="hidden" -->
* Anwendungsfall:
  * es gibt eine Liste, durch die durchgebl√§ttert werden kann
  * die jeweils neu geladenen Objekte sollen der Liste auch im Cache hinzugef√ºgt werden
  * Vorteil: wenn Benutzer dann nochmal zur√ºckbl√§ttert, sind die Objekte schon da
* Dazu liefert `useQuery` eine weitere Funktion zur√ºck: `fetchMore`

* Diese Funktion akzeptiert im einfachsten Fall neue Query _Variablen_ und f√ºhrt den Query neu aus
* ```javascript
  function FeedPage() {
    const { loading, data, error, fetchMore } = useFeedPageQuery();

    // ...

    const handleFetchMore = () => {
      fetchMore({
        variables: {
          page: data.stories.page.pageNumber + 1, // fetch next page
        },
      });
    };

    return <div>
       {data.page.hasNext && <button onClick={handleFetchMore}>Next</button>}
       // ...
    </>
  }
  ```
* Die geladenen Daten landen aber nicht im Cache üò≠
* <!-- .element: class="demo" --> Cache im DevTools mit fetchMore
---
### Type Policy
<!-- .slide: data-visibility="hidden" -->
* Mit einer **Type Policy** muss die Aktualisierung des Caches f√ºr ein Feld angepasst werden
  * Achtung 1: Das ist - je nach Schema, Query und Fachlichkeit - nicht trivial!
  * Achtung 2: TypeScript-Support an der Stelle nur eingeschr√§nkt!
* In der Cache-Konfiguration beim Erzeugen des Apollo Clients:
* ```javascript
  const apolloClient = new ApolloClient({
    // ...
    cache: new InMemoryCache({
      typePolicies: {
        Query: {
          fields: {
            stories: {
              keyArgs: false,
              merge(
                existing: StoryConnection | undefined | null,
                incoming: StoryConnection
              ) {
                if (!existing) { return incoming; }
                const merged = {
                  page: incoming.page,
                  stories: [...existing.stories, ...incoming.stories],
                };
                return merged;
              }  }  }  } }
            }),
        });
  ```
  * <!-- .element: class="demo" -->Der Cache in den Developer-Tools mit fetchMore-Funktion in FeedPage

---
### Ausblick: Aktualisieren des Caches mit Subscriptions
<!-- .slide: data-visibility="hidden" -->
<!-- .slide: class="left" -->
* Bei den bisher gesehen Aktualisierungen, hat der Client die Aktualisierung
  ausgel√∂st.
* Dadurch werden √Ñnderungen an Daten, die nicht vom Server vorgenommen werden, aber nicht
  ber√ºcksichtigt
* Beispiel: Anderer Benutzer erzeugt einen Kommentar
* Man kann das Query-Ergebnis (insb. f√ºr Listen) mit einer Subscription aktualisieren
* Beispiel: onNewComment Subscription
---
### Ausblick: Aktualisieren des Caches mit Subscriptions
<!-- .slide: data-visibility="hidden" -->
<!-- .slide: class="left" -->
* `useQuery` stellt dazu die Funktion `subscribeToMore` zur Verf√ºgung
* Dieser Funktion wird √ºbergeben:
  * Als Typ-Parameter der Name des Typs, der das Ergebnis der Subscription beschreibt
  * Als Parameter ein Objekt:
    * mit `document` (Ergebnis des `gql`-Aufrufs mit der Subscription bzw. des generierten Codes)
    * evtl. `variables` f√ºr die Mutation
    * `updateQuery`-Funktion
* Immer wenn die Subscription neue Daten liefert, wird die Callback-Funktion `updateQuery`
  mit den alten und neuen Daten aufgerufen
* In `updateQuery` k√∂nnen die neuen Daten dem Cache hinzugef√ºgt werden
* <!-- .element: class="demo" --> Cache Verhalten in Apollo Dev Tools
---
### Ausblick: Aktualisieren von Listen mit Subscriptions
<!-- .slide: data-visibility="hidden" -->
<!-- .slide: class="left" -->

* ```javascript
  function StoryComments({ storyId }) {

    // initial Kommentare f√ºr eine Story lesen
    const { data, loading, error, subscribeToMore } = useStoryCommentsQuery({
      variables: { storyId },
    });

    React.useEffect(() => {

      // Aktualisieren der Liste im Cache mit Subscription
      subscribeToMore<OnNewCommentSubscription>({
        document: OnNewCommentDocument,
        variables: { storyId },
        updateQuery: (prev, { subscriptionData }) => {
          // Wenn die Subscription keine Daten geliefert hat (z.B. Fehler)
          // den alten Cache-Inhalt unver√§ndert zur√ºckliefern
          if (!subscriptionData.data) return prev;

          // Bestehenden Cache-Inhalt ('prev') kopieren und in das
          // 'comments'-Feld den neuen Kommentar einf√ºgen

          // Achtung! Wie das einf√ºgen genau funktioniert, h√§ngt nat√ºrlich
          //  immer von deiner jeweiligen Daten-Struktur ab
          const newComment = subscriptionData.data.onNewComment.newComment;
          const newData = Object.assign({}, prev, {
            comments: [newComment, ...prev.comments],
          });

          // Neuen Wert zur√ºckliefern; dieser ersetzt dann
          // den gecachten Wert des Queries, f√ºr den diese
          // updateQuery-Funktion ausgef√ºhrt wurde
          return newData;
        },
      });
    }, [subscribeToMore, storyId]);

    return ...;
  }
  ```
---
### √úbung: Den Cache manuell aktualisieren
* Implementiere die `update`-Funktion f√ºr die `addPost`-Mutation
* Beschreibung findest Du in `workspace-graphql-advanced/src/PostEditorPage.tsx`

---
### Field Policies

* Mit einer [Field Policy](https://www.apollographql.com/docs/react/caching/cache-field-behavior) kann die Interaktion mit dem Cache beim Zugriff auf ein Feld angepasst werden
* Man kann damit konfigurieren:
  * was beim Lesen eines Feldes passieren soll
  * was beim Schreiben des Feldes in den Cache passieren soll
  * Mit `keyargs` k√∂nnt ihr Argumente eines Feldes angeben, die nicht Bestandteil des Cache-Keys sein sollen
* <!-- .element: class="demo" --> `workspace-graphql-advanced/index.tsx`  

---

### Angabe der Field Policies

* Die Policy f√ºr ein Field kann in der `Type Policy` des Parent-Typen gesetzt werden
* Die Type Policies werden in der Cache-Konfiguration gesetzt.
* Dabei handelt es sich um ein Objekt, das als Keys Namen von Objekt Typen aus Eurem GraphQL Schema enth√§lt
* Als Wert wird jeweils ein Objekt mit dem Property `fields` √ºbergeben.
* In diesem Objekt sind dann die Keys die Feldnamen des Typen. Die zugeh√∂rigen Werte sind dann die Field Policies
* Beispiel: eine `read`-Policy f√ºr das `title`-Field am `Post`-Typen.
  * ```javascript
    const cache = new InMemoryCache({
      typePolicies: {
        // Name des Typen: "BlogPost"
        BlogPost: {
          fields: {
            // Name des Feldes, das konfiguriert werden soll: "title"
            title: {
              read(currentTitle) { return currentTitle.toUpperCase() }
            }
          }
        }
      }
    });
  ```
---
### Details: Die read-Funktion 
* Wenn man f√ºr einen Typen nur eine `read`-Funktion definiert, kann man eine kompaktere Schreibweise w√§hlen:
  * ```javascript
    const cache = new InMemoryCache({
      typePolicies: {
        BlogPost: {
          fields: {
            // title ist hier kein Objekt, sondern direkt read-Funktion
            title(currentTitle) { return currentTitle.toUpperCase() }
          }
        }
      }
    });
  ```
* √úber den zweiten Parameter, bekommt man Zugriff auf die √ºbergebenen Feld-Argumente
  * ```javascript
    const cache = new InMemoryCache({
      typePolicies: {
        BlogPost: {
          fields: {
            title(currentTitle, { args } ) { 
              return args.transform === "uppercase" ? currentTitle.toUpperCase() : currentTitle 
            }
          }
        }
      }
    });
  ```
* Nur sparsam (falls √ºberhaupt) verwenden, denn in der Regel sollte ja die Logik auf dem Server ausgef√ºhrt werden
---
### Client-only Felder
* Der Apollo Client erlaubt es, das GraphQL Schema um Felder zu erweitern, die nur auf dem Client zur Verf√ºgung stehen
* Die Logik f√ºr diese Felder wird dann in der `read`-Funktion der entsprechenden `FieldPolicy` hinterlegt
* Ist das eine gute Idee? Wof√ºr w√ºrdet ihr das nutzen? ü§î

---
### Beispiel: Client-only Felder

* Formatiertes Datum im BlogPost
* Mit der `@client` Direktive gebt ihr an, dass das Feld ein "client-only" Feld ist
  * ```graphql
      query PostPage($postId: ID!) {
        post(postId: $postId) {
          id
          title
          date
          # Client-only Feld
          formattedDate @client
          body
          likes
        }
      }
    ```
* Zur Ermittlung des Wertes legt ihr eine FieldPolicy an:
* ```typescript
    const client = new ApolloClient({
      cache: new InMemoryCache({
        typePolicies: {
          BlogPost: {
            fields: {
              formattedDate(_, { readField }) {
                const date = readField("date");
                if (typeof date === "string") {
                  // Datum formatieren
                  return formattedDate(date); 
                }
              }
            }
          }
        }
      })
    });
  ```
---
### Client-only Felder
* Achtung: Ihr m√ºsst auch den Code-Generator umkonfigurieren, damit der Eure Client-only-Felder kennt
* Dazu neue Schema-Datei anlegen und in die `codegen.yml`-Datei eintragen:
  * ```graphql
    #./client-schema.graphql
    directive @client on FIELD

    extend type BlogPost {
      formattedDate: String!
    }
    ```
  * Konfigurationsdatei:  
  * ```yaml
    generates:
      src/generated/graphql.tsx:
        schema: ./client-schema.graphql
      ...
    ```

---
## Reactive Variables
    
---
### Reactive Variables
* [Reactive Variables](https://www.apollographql.com/docs/react/local-state/managing-state-with-field-policies#storing-and-updating-local-state-with-reactive-variables) sind eine M√∂glichkeit, globalen Zustand zu halten (ohne Apollo Cache)
* <!-- .element: class="demo" --> Fertiges Beispiel: Bookmarks in der Sidebar (`steps/35-graphql-advanced`)
* <!-- .element: class="demo" --> Reactive Variables (workspace-graphql-advanced)


---
### Reactive Variables
* Eine reaktive Variable wird mit `makeVar` angelegt.
  * Als Parameter wird der initial Wert √ºbergeben
  * Als Typ-Parameter kann der TypeScript des gehaltenen Werts √ºbergeben werden
* ```javascript
    import { makeVar } from "@apollo/client";
    const counterVar = makeVar<number>(0);
  ```
* Zur√ºckgeliefert wird eine Funktion, die zum Lesen und Schreiben des aktuellen Wertes dient
  * Wenn die Funktion ohne Parameter aufgerufen wird, wird der aktuelle Wert zur√ºckgegeben:
    * ```javascript
      const currentCounter = counterVar();
      ```
  * Wenn du der Funktion einen Wert √ºbergibst, wird dieser Wert als neuer Wert gesetzt.
    * ```javascript
      counterVar(currentVar + 1);
      ```
    * Achtung! Wie bei React State ist der Wert immutable!
    * Objekte und Arrays also nicht direkt ver√§ndern, sondern kopieren und die Kopien dann √§ndern und setzen
  
---
### Reactive Variables: Verwendung in React
* Die React Variables sind im (React-unabh√§ngigen) Apollo Client implementiert
* Mit dem [`useReactiveVar`](https://www.apollographql.com/docs/react/local-state/reactive-variables#usereactivevar-hook) kannst Du eine Variable in einer React Komponente auslesen
  * Wenn die Variable sich √§ndert, wird die Komponente neu gerendert
  * Dem Hook √ºbergibst Du die Funktion, die `makeVar` zur√ºckgeliefert hat
  * ```javascript
      // counter.ts
      export const counterVar = makeVar<number>(0);
    ```
  * ```javascript
      // CountView.tsx  
      function CountView() {
        const currentCount = useReactiveVar(counterVar);

        // ...
      }
    ```
  * Setzen der Variable unver√§ndert, wie bereits gesehen
  * ```jsx
      // CountView.tsx  
      function CountView() {
        const currentCount = useReactiveVar(counterVar);

        return <button onClick={ () => counterVar(currentCount+1) }>
          Increase {currentCount}</button>
      }
    ```

---
### Reactive Variablen: √úbung

* Baue das Bookmark-Feature f√ºr die Blog-Anwendung
* Verzeichnis: `workspace-graphql-advanced`
* Im "globalen Zustand" soll eine Liste von Bookmarks gehalten werden
* Ein `Bookmark` ist ein Objekt mit zwei Eigenschaften: `title` und `path`
* Unter der Artikelvorschau (`PostTeaser` in der `PostList`) soll ein Button
  hinzugef√ºgt werden, mit dem der Artikel den Bookmarks hinzugef√ºgt wird
  * Der `title` soll der Titel des Artikels sein
  * Der `path` ist `/post/${post.id}` (kannst Du in der Sidebar als `Link` verwenden)
* In der Sidebar soll eine Liste aller Bookmarks angezeigt werden
  * Hinter dem Bookmark soll ein Button o.√§. sein, mit dem man den Post wieder  
    entfernen kann
  * √úber den `path` des Bookmarks kannst Du auch einen Link zur Post-Ansicht bauen, wenn Du willst (`<Link to={bookmark.path}>...</Link>`)  
* Weitere Hinweise findest Du in `bookmarks.ts`
* L√∂sung: `steps/35-graphql-advanced`
* Wenn Du fertig bist, bitte die Hand in Zoom heben ‚úã


  </textarea
          >
        </section>
        <!-- ============================================================================== -->
        <!-- ====                                                                      ==== -->
        <!-- ====            C O N T E X T                                             ==== -->
        <!-- ====                                                                      ==== -->
        <!-- ============================================================================== -->
        <section id="t-context">
          <h2>React Context API</h2>
          <p>Kein Statemanagement, aber h√§ufig zusammen erw√§hnt</p>
          <p>"Dependency Injection"</p>
          <p>√úberblick: üëâ Anwendungshierachie mit State und Props (Miro)</p>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Hintergrund: Globaler Zustand</h3>
          <ul>
            <li>
              Man kann Zustand in <b>lokalen Zustand</b> und <b>globalen Zustand</b> einteilen
            </li>
            <li>
              <b>Lokaler Zustand</b> ist Zustand, der "mehr oder weniger" einer Komponente zur
              Verf√ºgung steht
            </li>
            <li>
              <b>Globaler Zustand</b> hingegen ist f√ºr die ganze Anwendung oder gro√üe Teile davon
              zust√§ndig
            </li>
            <li>Die √úbgerg√§nge sind flie√üend, es gibt keine fixe Definition</li>
            <li>Beispiele f√ºr globalen Zustand: angemeldeter Benutzer, Theme</li>
          </ul>
        </section>

        <section>
          <h2>Im Detail: Context API</h2>
          <p>Beispiel: <code>context-example/context-workspace</code></p>
          <p>
            In <code>Container.tsx</code> Anzeige der Border einschalten (<code
              >hideBorder = false</code
            >)
          </p>
          <p><code>CounterApp</code> rendern!</p>
          <p>
            In <code>Container.tsx</code> Anzeige der Renderings einschalten (<code
              >showRenderings = true</code
            >)
          </p>
          <p>(Material in <code>context-example/material/CounterContext.txt</code>)</p>
        </section>

        <section>
          <h2>Context...</h2>
          <p>
            <em
              >erlaubt das Durchreichen von Informationen ohne explizites angeben als Properties</em
            >
          </p>

          <ul>
            <li>funktioniert nur innerhalb einer Hierarchie-Ebene</li>
            <li>es k√∂nnen beliebg viele (fachliche) Context definiert werden</li>
            <li>besteht aus <code>Provider</code> und <code>Consumer</code></li>
            <li>
              <a href="https://reactjs.org/docs/context.html" target="_blank">Doku</a>
            </li>
          </ul>
        </section>

        <section>
          <h2>Context Factory</h2>
          <ul>
            <li>
              <em>erzeugt ein Objekt, mit <b>zwei Komponenten</b></em>
            </li>
            <li>
              <code>Provider</code>, stellt Objekt mit Key-Value-Paaren zur Verf√ºgung (der
              Context-"Value")
            </li>
            <li>
              <code>Consumer</code> wird in eigener Komponente verwendet, um auf einen Context
              zuzugreifen ("versteckt" durch useContext Hook)
            </li>
            <li>
              <pre><code class="line-numbers" data-leftpad>
import react from "React";

const AuthContext = React.createContext();

// erzeugt:
// AuthContext.Provider 
// AuthContext.Consumer (mit Hooks API √ºberfl√ºssig)

export AuthContext;
                      </code></pre>
            </li>
          </ul>
        </section>

        <section data-markdown>
          <textarea data-template>
## Context Factory mit TypeScript

* Der `createContext` kann ein Typ-Parameter √ºbergeben werden, der den Context-Wert beschreibt
* `createContext` ben√∂tigt dann einen Default-Wert, der diesem Typen entspricht
  * Der Default-Wert wird in der Anwendung in der Regel nicht verwendet
  * Wird nur verwendet, wenn (f√§lschlich) auf den Kontext zugegriffen wird, ohne dass es einen Provider
    gibt
* ```typescript
  type IAuthContext = { 
    username: string | null;
    onLogin(newUser: string): void;
    onLogout(): void;
  }

  const AuthContext = React.createContext<IAuthContext>({
    // Dummy-Implementierung vom Default Context
    username: null,
    onLogin() {},
    onLogout() {}
  });

  export AuthContext;
  ```

          </textarea>
        </section>

        <section data-markdown>
          <textarea data-template>
## Context Provider

* _Eine React-Komponente, die einen Context zur Verf√ºgung stellt_
  * wird innerhalb einer eigenen Komponente eingebunden und zur√ºckgeliefert
  * Nimmt ein Objekt ("Context") mit beliebigen Werten entgegen (`value`-Property)
  * Woher die Werte kommen (State, Props, anderer Kontext, ...) spielt keine Rolle!
  * Alle Eintr√§ge des Objektes sind f√ºr die Konsumenten verf√ºgbar
* ```typescript
  const AuthContext = React.createContext&lt;IAuthContext>(/*...*/); // wie gesehen

  type AuthProviderProps = {
    children: React.ReactElement
  }

  export function AuthProvider(props: AuthProviderProps) {
      const [ currentUser, setCurrentUser ] = React.useState(null);

      const contextValue: IAuthContext = {
        // the current user
        currentUser,

        // function to set new user
        function onLogin(name) { setCurrentUser(name) },
        function onLogout() { setCurrentUser(null) }
      };

      return &lt;AuthContext.Provider value={contextValue}>
        {props.children}
      &lt;/AuthContext.Provider>;
  }             
  ```
  </textarea
          >
        </section>

        <section>
          <h2>useContext-Hook</h2>
          <p><em>Zugriff auf die Werte aus dem Context</em></p>
          <p>
            In allen Komponenten unterhalb der Provider Komponente, kann mit
            <code>useContext</code> auf den Kontext zugegriffen werden
          </p>

          <pre><code class="javascript">
import { AuthContext } from "auth-context";

function UserBadge() {
  const { currentUser } = React.useContext(AuthContext);

  return currentUser  ? &lt;h1>Welcome, {currentUser}&lt;h1> : null;
}            
          </code></pre>

          <p>Aufrufen einer Funktion aus dem Context</p>
          <p>√Ñndert im Context den Zustand der Provider-Komponente</p>
          <p>Alle Konsumer werden neu gerendert und k√∂nnen den neuen Wert verwenden</p>
          <pre><code class="javascript">
function UserBadge() {
  const { currentUser, logout } = React.useContext(AuthContext);

  return currentUser  ? 
    &lt;>&lt;h1>Welcome, {currentUser}&lt;h1>&lt;button onClick={logut}>Logout&lt;/button>&lt;/> 
    : null;
}                
          </code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
## Zugriff mit Custom Hook

* √úbliches Pattern: f√ºr den Zugriff auf den Context wird ein eigener Hook zur Verf√ºgung gestellt
* ```typescript
  export function useAuthContext(): IAuthContext {
    const authContext = useContext(AuthContext);

    return authContext;
  }            
  ```
* ```typescript
  import { useAuthContext } from "auth-context";
  
  export default function UserBadge() {
    const authContext = useAuthContext();
  }
  ```  

  * "Versteckt" den Context (Implementierungsdetail!) vor der Anwendung
  * Sieht aus wie fachliche API
  * Kann (vergleichsweise einfach) gemockt werden
---
###  Zugriff mit Custom Hook in TypeScript
* Beim Erzeugen des Context muss man (in TypeScript) einen Default Context angeben:
* ```typescript
  const defaultContext: IAuthContext = {
      // Dummy-Implementierung vom Default Context
      username: null, onLogin() {}
  }
  const AuthContext = React.createContext<IAuthContext>(defaultContext);
  ```
* Das ist nicht immer (sinnvoll) m√∂glich, so dass man auch `ContextType | null` verwenden k√∂nnte:
* ```typescript
  const AuthContext = React.createContext<IAuthContext | null>(null);
  ```
* Nun liefert `useContext` aber immer auch `null` zur√ºck, so dass die Verwendung jedes Mal √ºberpr√ºft werden muss:
* ```typescript
  function UserBadge() {
    const { username } = useContext(AuthContext); // ERR: Property 'username' does not exist on type 'IAuthContext | null'
  }
  ```
 
* Mit dem Custom Hook kann eine Plausibilit√§tspr√ºfung durchgef√ºhrt werden und ggf. ein sprechender Fehler erzeugt werden:
* ```typescript
  
  export function useAuthContext(): IAuthContext {
    const authContext = useContext(AuthContext);

    if (authContext === null) {
      throw new Error("AuthContext not correctly initialized. Please wrap your application in a AuthContextProvider component");
    }

    return authContext;
  }            
  ```  

---
### Ein "halbglobaler" Context
<!-- .slide: class="left" -->
* Ein Formular hat eine beliebige Menge von Feldern und Button
* Kann man da mit Context was machen? ü§î

* ```typescript
  
    type FormState = Record<string, string>;

    function PersonForm() {
      const [formState, setFormState] = React.useState<FormState>({});

      function onClearForm() {
        setFormState({});
      }

      function onFieldChange(fieldname: string, value: string) {
        setFormState({
          ...formState,
          [fieldname]: value
        });
      }

      return (
        <Container title="PersonForm">
          <FieldSet>
            <Input name="firstname" formState={formState} onFieldChange={onFieldChange} />
            <Input name="lastname" formState={formState} onFieldChange={onFieldChange} />
          </FieldSet>
          <ClearButton onClearForm={onClearForm} />
        </Container>
      );
    }

  ```

---
## √úbung: Ein Formular-Context

* *Baue einen Kontext, der Daten eines Formulars h√§lt und diese ver√§ndern kann*
* Schritte:
  * In `context-example/context-workspace` bitte Abh√§ngigkeiten installieren und npm starten:
  * ```bash
    cd context-example/context-workspace

    npm install
    npm start 
    ```
  
* In der `App.tsx`-Datei ist ein Formular implementiert (ohne Kontext).
* Die Formulardaten und Callback-Funktionen sollen in einen Kontext.
* N√§here Informationen findest Du direkt in der Datei.
* M√∂gliche L√∂sung findest Du in `steps/10_PersonForm_mit_context.tsx`
* Wenn Du fertig bist, bitte "Hand heben" in Zoom üôã‚Äç‚ôÄÔ∏è

---
### Formular-Beispiel: was g√§be es f√ºr eine Alternative?

* Wenn wir _keinen_ Kontext haben wollen, aber ein wiederverwendbares Formular "Framework"? ü§î

* Man k√∂nnte `formState` und die Funktionen zum √Ñndern in einen Custom Hook packen
* ```typescript
    function useForm() {
      const [formState, setFormState] = React.useState<FormState>({});

      function onClearForm() {
        setFormState({});
      }

      function onFieldChange(fieldname: string, value: string) {
        setFormState({
          ...formState,
          [fieldname]: value
        });
      }

      return { formState, onClearForm, onFieldChange };
    }

    function PersonForm() {
      const { formState, setFormState, onFieldChange } = useForm();

      return (
        <div>
          <FieldSet>
            <Input name="firstname" formState={formState} onFieldChange={onFieldChange} />
            <Input name="lastname" formState={formState} onFieldChange={onFieldChange} />
          </FieldSet>
          <ClearButton onClearForm={onClearForm} />
        </div>
      );
    }  
  ```
* Vorteile? Nachteile? ü§î

---
### Renderverhalten von Context

* <!-- .element: class="demo" --> Eine Komponente in den Kontext (`CounterContext`) hinzuf√ºgen
* <!-- .element: class="demo" --> Was passiert und warum? ü§î

---
### Renderverhalten von Context
* Die `children` werden fertig √ºbergeben
* Deren Renderzyklus wird von der Komponente bestimmt, die die `children` erzeugt
  * Das ist hier der Aufrufer von `Form`

* ```typescript
    function Form({ children }: FormProps) {
      // ...
      return (
        <Container title="Form">
          <FormContext.Provider
            value={ /* ... */ }
          >
            {children}
          </FormContext.Provider>
        </Container>
      );
    }  
  ```
---
### Renderverhalten von Context #2
* Unterdr√ºcken von erneutem Rendern
* <!-- .element: class="demo" --> `CounterDispay` aufteilen in lesen und schreiben

---
### Wie k√∂nnen wir das Rendern von Konsumenten unterdr√ºcken?
* Der `Clear`-Button wird immer gerendert, auch wenn der sich gar nicht √§ndert üò¢
* Woran liegt das?
* Was m√ºssen wir tun, damit der nicht gerendert wird?
  * Wenn sich _irgendetwas_ im Kontext √§ndert, werden _alle_ Konsumenten neu gerendert
    * Auch wenn sie auf Teile des Kontextes zugreifen, der sich nicht ver√§ndert hat.
  * Um den `Clear`-Button vom Rendern auszuschliessen, muss also die `onClearForm`-Funktion
    aus dem `FormContext`
  * Dazu wird ein neuer Context erzeugt. Je nachdem kann eine Komponente dann den einen oder
    anderen (oder beide) konsumieren.
---
### Rendern optimieren
<!-- .slide: class="left" -->
* Beispiel: zwei Kontexte f√ºr das Formular
* ```typescript
    // FormContext wie bisher, aber ohne onFieldChange und ohne onClearForm

    // Neuer Context:
    type IFormChangeContext = {
      onClearForm(): void;
      onFieldChange(fieldname: string, value: string): void;
    };

    const FormChangeContext = createContext<IFormChangeContext | null>(null);
  ```
* ```typescript
    function Form({ children }: FormProps) {
      // state + Callback-Funktionen wie bisher

      return (
        <FormContext.Provider
          value={{
            formState
          }}
        >
          <FormChangeContext.Provider value={{ onClearForm, onFieldChange }}>
            {children}
          </FormChangeContext.Provider>
        </FormContext.Provider>
      );
    }  
  ```
* Geht das?  
* <!-- .element: class="demo" --> Pr√ºfen!    
---
### Memoisieren von Komponenten
* Wenn eine Komponente gerendert wird, werden grunds√§tzlich _alle_ Unterkomponenten gerendert
* Das bedeutet im gezeigten Fall:
  * beim Rendern von `Form` wird *immer* auch `FormContext.Provider` gerendert und *immer* auch `FormChangeContext.Provider`.
  * Wir haben also noch nichts gewonnen.
  * Oder? ü§î
    * Eventuell haben wir immerhin eine sauberere Architektur durch Trennung in "lesenden" und "modifizierenden" Context
---
### Memoisieren von Komponenten  
* Man kann das Rendern von Komponenten durch "Memoiseren" (eine Art Caching) unterdr√ºcken
* Komponenten werden dann nur gerendert, wenn sich ihre Properties ver√§ndert haben.
* Variante 1 mit `React.memo`
* ```typescript
  const FormChangeContextProvider = React.memo( 
    function FormChangeContextProvider({ children, onClearForm, onFieldChange }) {
      return  <FormChangeContext.Provider value={{ onClearForm, onFieldChange }}>
        {children}
      </FormChangeContext.Provider>
    }
  );
  ```
* F√ºr den Verwender ist das transparent:  
* ```typescript
  function Form({ children }: FormProps) {
    // ...
    return  <FormContext.Provider value={/* ... */}>
        <FormChangeContextProvider 
          onClearForm={onClearForm}
          onFieldChange={onFieldChange}
          >{children}</FormChangeContextProvider/>
      </FormContext.Provider>
  }
  ```
* Diese Komponente wird nun neugerendert, wenn sich eines der Properties √§ndert (`children`, `onClearForm` und/oder `onFieldChange`)
* Reicht das? ü§î
---
### Memoisieren von Komponenten
* Eine Komponente ist eine Funktion
* Die Funktion wird bei jedem Rendern neu ausgef√ºhrt
* Alle Dinge, die darin erzeugt werden, sind bei jedem rendern "neu" (neue Referenz)!
* ```typescript
  function Form() {
    const onClearForm = () => setFormState({});

    return ...;
  }
  ```
* `onClearForm` ist bei jedem Rendern von `Form` "neu"
* Dasselbe gilt f√ºr Objekte
* ```typescript
  function Form() {
    const emptyArray = [];
  ```
* `emptyArray` ist bei jedem Rendern von `Form` "neu"
* Wir m√ºssen also daf√ºr sorgen, dass diese Werte und Funktionen "stabil" √ºber mehrere Renderzyklen sind
---
### useMemo und useCallback
* Um Werte √ºber mehrere Renderzyklen zu erhalten, kann man `useMemo` (Werte) und `useCallback` verwenden
  * (`useCallback` ist eine Vereinfachung von `useMemo` f√ºr Funktionen)
* Die Verwendung von beiden erinnert an `useEffect` üò±:
  * Es gibt eine Callback-Funktion (die liefert den Wert bzw. die Funktion zur√ºck)
  * Es gibt ein Dependency-Array, das bestimmt, wann der Wert/Funktion ung√ºltig ist.
  * Das Dependency-Array _muss_ angegeben werden - im Gegensatz zu `useEffect`. Warum?
* ```typescript
  function Form({title, subtitle}) {
    // Funktion wird nur einmal erzeugt
    const onClearForm = useCallback( () => setFormState({}), []);

    // Array wird immer neu erzeugt, wenn title oder subtitle sich √§ndert
    const titleArray = useMemo( () => { return [title, subtitle] }, [title, subtitle] );
  }
  ```
* Damit haben wir nun unser Problem gel√∂st?
---
### useMemo und useCallback: stale Values
* Was passiert denn hier:
* ```typescript
  function Form() {
    const [formState, setFormState] = React.useState({});

    const onFieldChange = useCallback(function(fieldname, value) {
      setFormState({
        ...formState,
        [fieldname]: value
      });
    }, []);
  }
  ```
* Der Wert von `formState` wird beim erstmaligen rendern innerhalb der Callback-Funktion "eingefroren" 
* Werte in einer Funktion (Closure) haben immer den Wert von dem Zeitpunkt, zu dem die Funktion ausgef√ºhrt wurde
* Das f√§llt h√§ufig gar nicht auf
* Hier schon, denn formState verbleibt immer auf dem ersten Wert üò¢
* Was k√∂nnen wir tun?

---
### useMemo und useCallback: stale Values
* Genau wie bei `useEffect` k√∂nnen wir bei `useMemo` und `useCallback` bestimmen, wann der gecachte Wert ung√ºltig ist
* Im gezeigten Beispiel w√§re das, wenn `formState` sich √§ndert:
* ```typescript
    function Form() {
      const [formState, setFormState] = React.useState({});

      const onFieldChange = useCallback(function(fieldname, value) {
        setFormState({
          ...formState,
          [fieldname]: value
        })
      }, [ formState ]);
    } 
  ```
* Ist das gut?
  * Es kommt drauf an!
---
### useMemo und useCallback: stale Values
* Grunds√§tzlich kann es richtig sein, bei √Ñnderung von Werten auch neue Werte und Funktionen zu erzeugen
* Wir wollen ja nicht "f√ºr immer" cachen, sondern nur so lange "wie es geht"
* Im gezeigten Fall w√ºrde das f√ºr die Form bedeuten:
  * Immer wenn sich der State √§ndert, √§ndert sich `onFieldChange`
  * Dadurch wird dann auch `FormChangeContextProvider` neu gerendert
  * Das bedeutet, wir haben nichts gewonnen: wenn sich der Zustand √§ndert, wir dauch der Clear-Button neugerendert
---
### Callback-Funktion von useState
* Im konkreten Fall k√∂nnen wir weiter optimieren, in dem wir beim Setzen des Zustandes eine Callback-Funktion angeben  
* Die Callback-Funktion wird von React aufgerufen und ihr wird der _aktuellste_ Werte des States √ºbergeben
* Die Callback-Funktion liefert dann den neuen State zur√ºck
* Damit haben wir keinen Wert mehr in der Closure, der "stale" sein k√∂nnte, und es reicht, wenn wir die Funktion
  einmal erzeugen (leeres Dependency Array)
* ```typescript
  function Form() {
    const [formState, setFormState] = React.useState({});

    const onFieldChange = useCallback(function(fieldname, value) {
      setFormState( () => return {
        ...formState,
        [fieldname]: value
      })
    }, [ ]);
  }   
  ```
---
### Memoisieren: memo, useCallback und useMemo
<!-- .slide: class="left" -->
* Sollte man das immer und √ºberall machen?
* Alles mit useMemo und useCallback umschliessen?
* ```typescript
  function Greet({name}) {
    const greeting = useMemo(`Hello, ${name}!`, [name]); // ü§î

    return <h1>{greeting}</h1>
  }  

  ```
* Was spricht daf√ºr? Was spricht dagegen? ü§î
---
### √úbung: Memoisieren von Komponenten
* Teile den `FormContext` in zwei Teile:
  * `FormContext`: die beiden Callback-Funktionen entfernen
  * `FormChangeContext`: hierein die beiden Funktionen zum Modifizieren des Zustands
* Einzige √Ñnderung im Verhalten: die `ClearButton`-Komponente soll den neuen Kontext verwenden (und sich _nicht_ neu rendern, wenn das Formular ausgef√ºllt wird)
* Kannst Du statt der gesehenen `FormChangeContextProvider` eine L√∂sung mit `React.useMemo` statt `React.memo` bauen? üò≥
* Wenn Du vorhin nicht fertig geworden bist, oder deine L√∂sung nicht funktioniert, kopiere `steps/10_PersonForm_mit_context.tsx` in deine `App.tsx`-Datei als Basis f√ºr die √úbung
* Eine fertige L√∂sung findest Du in `steps/20_PersonForm_mit_context_und_memo.tsx`
* Wenn Du fertig bist, bitte die Hand heben ‚úã

---
### Context vs Apollo Reactive Vars             
* Context: Standard React API
* Context: muss nicht global sein
* Reactive Vars k√∂nnen als Werte im Apollo Cache verwendet werden (`read`-Funktion)
* Reactive Vars "leben" au√üerhalb der Komponenten
  * Erzeugt als "normale" Variablen
  * Funktionen zum modifizieren "normale" Funktionen
* Identisch: wenn sich "irgendwas" in der Variable / Context √§ndert, werden alle Konsumenten neu gerendert
  * Bei Reactive Vars sind die Funktionen zum Modifizieren au√üerhalb, d.h. potentiell weniger Komponenten betroffen  
* Beispiel: `context-example/reactive-vars-vs-context`  
          

          </textarea>
        </section>
        <!-- ##################################### REDUX ############################################## -->
        <section data-markdown>
          <textarea data-template>
<!-- .slide: id="t-state" -->
## Globales Statemanagement mit Redux   

* Themen
* [Redux Grundlagen](#/t-redux)
* [Redux Toolkit](#/t-rtk)
* Asynchrone Actions mit [Redux Thunk](#/t-redux-thunk)
* Data Fetching mit [Redux Toolkit Query](#/t-rtk-query)

</textarea
          >
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Globaler Zustand</h3>
          <ul>
            <li>
              Man kann Zustand in <b>lokalen Zustand</b> und <b>globalen Zustand</b> einteilen
            </li>
            <li>
              <b>Lokaler Zustand</b> ist Zustand, der "mehr oder weniger" einer Komponente zur
              Verf√ºgung steht
            </li>
            <li>
              <b>Globaler Zustand</b> hingegen ist f√ºr die ganze Anwendung oder gro√üe Teile davon
              zust√§ndig
            </li>
            <li>Die √úbgerg√§nge sind flie√üend, es gibt keine fixe Definition</li>
            <li>Beispiele f√ºr globalen Zustand: angemeldeter Benutzer, Theme</li>
          </ul>
        </section>

        <section id="t-redux">
          <h2>External Statemanagement mit Redux</h2>
          <h3>Demo: Redux & Redux Devtools</h3>
          <p>üëâ steps/15-exkurs-redux-toolkit</p>
        </section>

        <section data-markdown>
          <textarea data-template>



# Redux Plain mit Thunk Action Plain
-> Editor
-> PostList (keine Posts laden)

# Thunk Actions Plain
-> Eine Thunk Action f√ºr PostList            


# Thunk Action mit createThunkAction
# Redux Toolkit Query            
  </textarea
          >
        </section>

        <section>
          <h3>Wiederholung</h3>
          <h2>Render Cycle in Pure React</h2>
          <img src="slides/images/redux-01-react-cycle-no-redux.png" style="height: 650px" />
        </section>

        <section>
          <h2>Redux extrahiert die Verantwortlichkeiten</h2>
          <img src="slides/images/redux-02-extracting-responsibility.png" style="width: 900px" />
        </section>

        <section data-markdown>
          <textarea data-template>
## Redux im Code
* <!-- .element: class="demo" -->Schritt-f√ºr-Schritt: "Plain Redux" 
* <!-- .element: class="demo" -->Schritt-f√ºr-Schritt: "Redux Toolkit"
* <!-- .element: class="demo" --> (jeweils workspace-redux)
---
## Strukturierter √úberblick √ºber alle Redux Teile            
* Wir sehen uns zun√§chst die Grundlagen des "klassichen" Redux an
* Im Projekt setzt man aber Redux Toolkit ein. Das sehen wir uns danach an.
* Hier geht's jetzt erstmal "nur" darum, die Konzepte und Ideen von Redux zu verstehen.
---
### Redux: Konzepte

* **Store**: eine Art "Datenbank", die au√üerhalb der Komponentenhierachie liegt. Hier ist der globale Zustand untergebracht. Komponenten werden √ºber Ver√§nderungen informiert und k√∂nnen sich re-rendern
* **Actions**: Einfache JavaScript-Objekte, die beschreiben was in einer Anwendung passiert. Bestehen aus einem Type und einem fachlichen Payload.
* **Reducer**-Funktionen: Funktionen, in denen die Logik zur Verarbeitung des Zustands untergebracht ist. Sie erhalten eine Action und einen (alten) Zustand, verarbeiten die Action und liefern neuen Zustand zur√ºck.
* **Action Creator**: Factory-Funktionen, die Action Objekte erzeugen
</textarea
          >
        </section>
        <!-- ============================================================================= -->

        <section data-markdown>
          <textarea data-template>
### Actions
* Pure JavaScript-Objekte, die eine Aktion in der Anwendung beschreiben
* Haben √ºblicherweise <b>type</b> und <b>payload</b>
* √úber das <b>type</b>-Property k√∂nnen sie identifiziert werden
* Der <b>Payload</b> enth√§lt Action-spezifische Daten
* Beispiel 1: Action-Objekt ohne Payload:
* ```typescript
{
type: "editor/clearDraft"; 
}
```
* Beispiel 2: Action-Objekt mit Payload:
* ```typescript
{
type: "editor/setDraftTitle",
newTitle: "..."  // Action-spezifischer Payload 
             // (hier: der neue Blog-Titel)
}
```


  </textarea
          >
        </section>
        <section>
          <h3>Reducer-Funktion #1</h3>
          <ul>
            <li>
              ...erh√§lt einen (vorherigen) Zustand und eine <em>Action</em> als Parameter √ºbergeben
            </li>
            <li>...verarbeitet die Action</li>
            <li>...liefert dann den neuen, aktualisierten Zustand zur√ºck</li>
            <li>...muss Seiteneffekt frei sein ("pure function")</li>
            <li>
              <pre><code class="javascript"  >
reducer(old_state, action) => new_state
</code></pre>
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Die reducer-Funktion #2</h3>
          <ul>
            <li>
              Bekommt den vorherigen Zustand √ºbergeben und liefert neuen Zustand zur√ºck (oder den
              unver√§nderten alten)
            </li>
            <li>Der Zustand ist immutable, deswegen den bestehenden Zustand immer kopieren!</li>
            <li>
              <pre><code class="javascript">
function editorReducer(state = initalDraftPost, action) {
switch (action.type) {

  case "editor/clearDraft":
    return initalDraftPost;

  case "editor/setDraftBody":
    return { ...state, body: action.body };

  case "editor/setDraftTitle":
    return { ...state, title: action.title };
    
  default:
    return state;
}
}
</code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h3>Redux: Store, Reducer und Actions</h3>
          <ul>
            <li>
              Der Store, d.h. der globale Zustand, wird ausschlie√ülich √ºber reducer-Funktionen
              verwaltet
            </li>
            <li>
              Jede reducer-Funktion verwaltet einen "Teil-Zustand" des globalen Zustandes. Die
              reducer k√∂nnen sich untereinander nicht sehen und nicht auf die anderen Teile des
              gloablen Zustands zugreifen. Ein Teil-Zustand wird auch als "Slice" bezeichnet (also
              ein Anwendungsteil)
            </li>
            <li>
              Wenn Du den Store mit einer Datenbank vergleichst, w√§re ein solcher Teilzustand so
              etwas wie eine Tabelle
            </li>
            <li>Die reducer werden beim Starten der Anwendung in Redux registriert</li>
            <li>
              Dadurch ist eine gute Entkopplung m√∂glich: ein Teil der Anwendung informiert √ºber eine
              Aktion ("User hat sich eingeloggt", "Theme wurde ver√§ndert") und alle interessierten
              Anwendungsteile k√∂nnen darauf reagieren
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Redux: Actions ausl√∂sen</h3>
          <ul>
            <li>Actions werden an <b>alle</b> Reducer-Funktionen verteilt</li>
            <li>
              Zum Ausl√∂sen einer Action gibt auch von Redux eine <code>dispatch</code>-Funktion, an
              die Du mit dem <code>useDispatch</code> Hook von Redux gelangst.
            </li>
            <li>
              <pre><code class="javascript">
function PostEditor() {
const dispatch = useDispatch();

function handleTitleChange(newTitle) {
  dispatch({ type: "editor/setDraftTitle", title });
}

// ...

&lt;input onChange={(e) => handleTitleChange(e.target.value) />
}
</code></pre>
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Action Creator...</h3>
          <ul class="no-fragment">
            <li>...sind "Factory-Funktionen", die deine Action-Objekte erzeugen</li>
            <li>...sind optional, werden aber nahezu immer verwendet</li>
            <li>
              <pre><code class="javascript">
function setDraftTitle(newTitle) {

return { 
  type: "editor/setDraftTitle", 
  title: newTitle
}

}  
</code></pre>
            </li>
            <li>Beim dispatchen wird dann der Action-Creator aufgerufen:</li>
            <li>
              <pre><code class="javascript">
function PostEditor() {
const dispatch = useDispatch();

function handleTitleChange(newTitle) {
  dispatch(setDraftTitle(newTitle));
}

// ...
}
</code></pre>
            </li>
          </ul>

          <p>ü§î Wof√ºr k√∂nnten Action Creator sinnvoll sein?</p>
          <ul>
            <li>Stellen sicher, dass Objekte korrekt aussehen</li>
            <li>Verbergen interne Struktur der Actions vor der Anwendung</li>
            <li>K√∂nnen plausibilit√§tspr√ºfungen machen</li>
            <li>K√∂nnen Daten konvertieren, bevor sie in die Action √ºbernommen werden</li>
          </ul>
        </section>

        <section>
          <h3>Redux: Zugriff auf den globalen Zustand</h3>
          <ul>
            <li>
              Komponenten k√∂nnen aus dem globalen Zustand (Store) die Daten ausw√§hlen, die sie
              ben√∂tigen
            </li>
            <li>
              Die Hierarchie-Ebene spielt dabei keine Rolle, weil der Zustand au√üerhalb, "neben" den
              UI Komponenten liegt
            </li>
            <li>
              Nur wenn sich die ausgew√§hlten Daten in einer Kompoente √§ndern, wird die Komponente
              neu gerendert
            </li>
            <li>
              Der <code>useSelector</code> Hook von Redux erwartet eine Callback-Funktion, die
              aufgerufen wird, sobald sich <em>irgendetwas</em> im Store ver√§ndert hat
            </li>
            <li>Dieser Callback-Funktion wird der komplette Store √ºbergeben.</li>
            <li>
              Aus dem Store w√§hlt die Komponente die f√ºr sie relevanten Daten aus und liefert sie
              zur√ºck
            </li>
            <li>
              Nur wenn sich diese zur√ºckgelieferten Daten ver√§ndert haben, wird die Komponente neu
              gerendert
            </li>
            <li>
              <pre><code class="javascript">
function PostEditor() {
const draftTitle = useSelector(state => state.editor.draftTitle);

//  ...
}
</code></pre>
            </li>
          </ul>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>useSelector - Details</h3>
          <ul>
            <li>
              Um festzustellen, ob sich die ausgew√§hlten Daten ver√§ndert haben, pr√ºft Redux auf
              <b>Identit√§t</b>!
            </li>
            <li>
              Es wird deshalb empfohlen, nur einzelne Werte (keine Objekte) aus dem Store
              auszuw√§hlen - stattdessen mehrere useSelector-Aufrufe machen. Bei Objekten musst Du
              eventuell die
              <a href="https://react-redux.js.org/api/hooks#equality-comparisons-and-updates"
                >shallowEqual-Funktion</a
              >
              √ºbergeben.
            </li>
            <li>
              Du kannst nat√ºrlich auch "abgeleitete" Daten zur√ºckliefern, Redux vergleicht nur den
              von dir zur√ºckgelieferten Wert, unabh√§ngig davon, ob er "direkt" aus dem Store kommt
              oder basierend auf dem Store "berechnet" wurde
            </li>
            <li>
              <pre><code class="javascript">
function AppHeader() {
// "abgeleiteter" Zustand
const hasDraftPost = useSelector(
  state => state.editor.draftTitle !== "" || state.editor.draftBody !== ""
);
}

// √ºbergebene Selector-Callback-Funktion 
//    wird bei JEDER √Ñnderung des Stores ausgef√ºhrt
// AppHeader wird nur neu gerendert, 
//    wenn sich deren R√úCKGABEWERT √§ndert
</code></pre>
            </li>
          </ul>
        </section>

        <section>
          <h3>Der Store</h3>
          <p>Ein <em>einziger</em> Store h√§lt den <em>kompletten</em> Zustand</p>
          <p>
            Der Store wird allen Componenten √ºber die Wrapper-Komponente <em>Provider</em>
            zur Verf√ºgung gestellt
          </p>
          <pre><code class="javascript">
import { store } from "./store";
import { Provider } from "react-redux";

const root = createRoot(document.getElementById("root"));

root.render(
&lt;Provider store={store}>
&lt;App />
&lt;/Provider>
);
    
</code></pre>
        </section>

        <!-- ============================================================================= -->
        <section>
          <h3>Redux Dev Tools</h3>

          <p>
            Mit den Redux Dev Tools kannst Du unter anderem im Browser den Store einsehen und die
            ausgel√∂sten Actions nachverfolgen
          </p>

          <ul>
            <li>
              <a
                href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=de"
                target="_blank"
                >Chrome</a
              >
            </li>
            <li>
              <a href="https://addons.mozilla.org/de/firefox/addon/reduxdevtools/" target="_blank"
                >Firefox</a
              >
            </li>
          </ul>
        </section>

        <section data-markdown>
          <textarea data-template>
<!-- .slide: id="t-rtk" -->
### Redux Toolkit
* _"The official, opinionated, batteries-included toolset for efficient Redux
development"_
* Das ist mittlerweile das "offizielle" Redux
* [https://redux-toolkit.js](https://redux-toolkit.js)
* Mit vorkonfiguriertem Setup (inklusive
[immer](https://github.com/immerjs/immer) f√ºr Reducer-Funktionen)
* Vereinfacht erheblich das Arbeiten mit Reducer, generiert z.B. Action Creator zur
Laufzeit
* Vereinfacht typische Anwendungsf√§lle wie API Calls mit dem integrierten [RTK Query](https://redux-toolkit.js.org/rtk-query/overview)

---
### createSlice    
* Ein "Slice" repr√§sentiert einen fachnlichen "Schnitt" in Eurer Anwendung
* Ein Slice wird mit der Funktion <code>createSlice</code> erzeugt
* Diese Funktion erwartet ein Konfigurationsobjekt
* legt den initialen Zustand fest
* definiert die Reducer-Funktionen
* F√ºr jede reducer-Funktion werden automatisch Action-Creator erzeugt
* ```typescript
const editorSlice = createSlice({
name: "editor",
initalState: { title: "", body: "" },
reducers: {
updateTitle(state, action) {
state.title = action.payload.newTitle
}
}
})
```
* ```typescript
const dispatch = useDispatch();

dispatch(editorSlice.actions.updateTitle({
newTitle: "Hello RTK"
}))
```
---
### TypeScript-Typen #1

* Der Typ des States eines Slices wird automatisch vom RTK aus dem `initialState` abgeleitet
* Nat√ºrlich k√∂nnt ihr daf√ºr auch explizit einen Typen definieren
* ```typescript
type EditorSliceState = { title: string, body: string }

const editorSlice = createSlice({
name: "editor",
initalState: { title: "", body: "" } as EditorSliceState,
// ...
})
```
* oder:
* ```typescript
type EditorSliceState = { title: string, body: string }

const initialState: EditorSliceState = { title: "", body: "" };

const editorSlice = createSlice({
name: "editor",
initalState,
// ...
})
```

---
### Reducer-Funktionen

* Das `reducers`-Objekt enth√§lt die Reducer-Funktionen f√ºr einen Slice
* Der Key bzw. der Funktionsname entspricht dem Reducer-Namen
* Die Funktion kann zwei Parameter bekommen:
1. Den aktuellen State des Slices
* **Achtung!**: Der State hier ist nur der State des jeweiligen Slices, nicht der Gesamt-State aller Slices!
* Ein Slice arbeitet immer nur auf "seinem" State und hat auch keinen Zugriff auf State anderer Slices.
2. Das Action-Objekt (optional. Wenn eine Action keinen Payload hat, k√∂nnt ihr den Parameter weglassen)
* Der √ºbergebene `state` ist ein [immer](https://immerjs.github.io/immer/) `Draft`-Objekt, das ihr direkt ver√§ndern d√ºrft:
* ```typescript
reducers: {
addBlogPost(state, action) {
state.posts.push({...}); // push ist erlaubt hier
state.posts[0].title = action.payload.newTitle; // direkte Modifikation erlaubt
}
}
```
* Alternativ k√∂nnt ihr auch ein komplett neues Objekt zur√ºckgeben, dann wird der bestehende
State durch das neue Objekt komplett ersetzt:
* ```typescript
reducers: {
clearEditor(state) {
return { title: "", body: ""}; 
}
}
```

---
### Action Creator  
* F√ºr jede Reducer-Funktion generiert das RTK automatisch eine Action-Creator-Funktion
* Die generierte Action-Create-Funktion erzeugt den _Payload_, der Action, die an die `reducer`-Funktion
als 2. Parameter √ºbergeben wird
* Die generierten Funktionen liegen im erzeugten Slice-Objekt unter `slice.actions`:
* ```typescript
const editorSlice = createSlice({ reducers: { updateTitle(...) { ... } });

const { updateTitle } = createSlice.actions;
// updateTitle kann 'dispatched' werden
```
---
### Actions im RTK

* Eine Action in RTK ist immer ein Objekt im folgenden Format:
* ```typescript
type Action<P> = {
type: string
payload: P
}
```
* Der `type` setzt sich aus dem `name` des Slices und dem Namen der Reducer-Funktion zusammen
* `editor/updateTitle`
---
### Action Payload  
* Der **Payload** ergibt sich aus dem zweiten Parameter der Reducer-Funktion
* Damit der Typ korrekt bestimmt werden kann, m√ºsst ihr einen TypeScript-Typen f√ºr den **Payload** definieren.
Diesen gebt ihr dann - "verpackt" im `PayloadAction`-Typen - f√ºr den Action-Parameter in Eurem Reducer an:
* ```typescript
type UpdateTitle = { newTitle: string };
```
* ```typescript
const editorSlice = createSlice({
reducers: {
updateTitle(state, action: PayloadAction<UpdateTitle>) {
state.title = action.payload.newTitle
}
}
})
```
* Auf diese Weise ist sowohl `action`-Parameter korrekt getypt als auch der Action-Creator:
* ```typescript
// OK
dispatch(editorSlice.actions.updateTitle({
newTitle: "Hello" 
}));

// ERR newTitle darf nicht null sein
dispatch(editorSlice.actions.updateTitle({
newTitle: null 
}));

// ERR newTitel statt newTitel
dispatch(editorSlice.actions.updateTitle({
newTitel: "Moin"
}));

```
---
### Extra Reducer

- Actions in Redux k√∂nnen prinzipiell von _allen_ Reducern verarbeitet werden
- Bislang haben wir nur gesehen, wie die Actions direkt von dem Reducer verarbeitet werden,
der sie "definiert" (als 2. Parameter)
- F√ºr alle weiteren Actions k√∂nnen `extraReducers` an einem Slice definiert werden
- Ein "extra reducer" ist eine gew√∂hnliche Reducer-Funktion, d.h. sie bekommt den State des Slices und eine Action √ºbergeben
- Welche Action sie √ºbergeben bekommt, kann sie an Hand verschiedener Kriterien ausw√§hlen
- Das `extraReducers`-Feld an `createSlice` ist eine Funktion, die ein `builder`-Objekt √ºbergeben bekommt
- Mit diesem `builder`-Objekt kann sie ihre Reducer definieren
* ```typescript
const editorSlice = createSlice({
// ...
extraReducers: builder => {
builder.addCase(logoutAction, (state, action) => {
  state.title = "";
  state.body = "";
}
}
})
```
---
### Extra Reducer
- √úber das `builder`-Objekt k√∂nnen Reducer hinzugef√ºgt werden
- Dabei wird jeweils ausgew√§hlt f√ºr welche Action(s) ein Reducer aufgerufen werden soll
- Dazu gibt es zwei Methoden (`addCase` und `addMatcher`)
- Der erste Parameter w√§hlt aus, ob eine Action verarbeitet werden soll oder nicht
- Der zweite Parameter ist die reducer-Funktion (identisch mit den Reducern aus `reducers`)
---
### Extra Reducer: addCase
- Mit `addCase` kann eine Action aus einem anderen Slice angegeben werden. Wenn diese Action ausgel√∂st wird,
wird die Reducer-Funktion aufgerufen:
* ```typescript
const userSlice = createSlice({ reducers: { logout(...) { ... }}});
export const { logout } = userSlice.actions;

const editorSlice = createSlice({
// ...
extraReducers: builder => {
builder.addCase(logout, (state, action) => {
  // action ist 'Logout'-Action aus 'userSlice'
  state.title = "";
  state.body = "";
}
}
})
```
---
### Extra Reducer: addMatcher
- Mit `addMatcher` wird eine CallbackFunktion angegeben
- Diese Funktion wird f√ºr jede Action aufgerufen und liefert `true` bzw. `false` zur√ºck, um zu entscheiden,
ob die Reducer-Funktion aufgerufen werden soll
- Die Funktion ist au√üerdem eine TypeScript [Type Predicate](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates)-Funktion. Dadurch ist die Reducer-Funktion dann
automatisch korrekt getypt.
* ```typescript

type SavePostAction = { type: "savePost", payload: { title: string, body: string } };

function isSavePostAction(a: AnyAction): a is SavePostAction {
return a.type === "savePost";
}

const editorSlice = createSlice({
// ...
extraReducers: builder => {
builder.addMatcher(isSavePostAction, (state, action) => {
  // Action ist eine SavePostAction
  // ...
}
}
})
```

---
### Verwenden des Slices

* Das erzeugte Slice-Objekt hat zwei Properties:
* `reducer`: Dieses Objekt wird in der Store-Konfiguration angegeben
* `actions`: enth√§lt die automatisch generierten Action-Creator-Funktionen
* Beide Teile k√∂nnt ihr exportieren, in der Regel wird `reducer` per `default` exportiert:
* ```typescript
const editorSlice = createSlice({ ... });

export default editorSlice.reducer;
export const { updateTitle, updateBody } = editorSlice.actions;
```
---
### Konfiguration
* Der globale Store wird mit der `configureStore`-Funktion erzeugt
* Diesem √ºbergebt ihr alle `reducer`, die ihr mit `createSlice` (oder auf "klassichem" Weg) erzeugt habt:
* ```typescript
import { configureStore } from "@reduxjs/toolkit";
import editor from "./editor-slice";
import posts from "./posts-slice";

export const store = configureStore({
reducer: {
editor,
posts
}
});
```
* **Achtung!** Der Name des Keys im `reducer`-Objekt bestimmt den "Pfad" im globalen State:
* Im Beispiel oben besteht der globale State aus zwei Root-Pfaden (`editor` und `posts`)
* Zugriff zum Beispiel: `useSelector( state => state.editor.title )`
* In folgenden Beispiel best√ºnde der State aus den Pfaden `editorSlice` und `posts`:
* ```typescript
export const store = configureStore({
reducer: {
editorSlice: editor,
posts
}
});
```
---
### Den Store bekannt machen

* Der Store ist ein Singleton, der beim Starten der Anwendung initial erzeugt wird
* Das erzeugte `store`-Objekt m√ºsst ihr √ºber die `Provider`-Komponente in Eure React-Anwendung bringen:
* ```typescript
import React from "react";
import { createRoot } from "react-dom/client";

import { configureStore } from "@reduxjs/toolkit";
import { Provider } from "react-redux";

import App from "./App";

const store = configureStore({ .... });

createRoot(document.getElementById("root"))
.render(
<Provider store={store}>
  <App />
</Provider>
);
```
---
### TypeScript-Typen f√ºr Zugriff auf den Store

* Aus dem erzeugten Store k√∂nnt ihr einen TypeScript-Typen f√ºr den globalen State erzeugen:
* ```typescript
export const store = configureStore({ ... });

export type RootState = ReturnType<typeof store.getState>;
```
* Den `RootState` k√∂nnt ihr jetzt z.B. f√ºr typsicheren Zugriff auf den State in `useSelector` verwenden:
* ```typescript
const title = useSelector<RootState>(state => state.editor.newTitle); // OK
const title = useSelector<RootState>(state => state.editor.newTitel); // ERR
```
* In der Regel erzeugt man sich eine `useAppSelector`-Funktion, die direkt den `RootState` Eurer Anwendung kennt:
* ```typescript
// redux-hooks.ts

import { TypedUseSelectorHook, useSelector } from "react-redux";
import { AppDispatch, RootState } from "./store";

export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;
```
* Typsichere Verwendung:
* ```typescript
import {useAppSelector} from "../redux-hooks"

function Editor() {
const title = useAppSelector(state => state.editor.title); // Typsicher!

// ...
}
```

---
### useAppDispatch

* Auch f√ºr die `useDispatch`-Funktion k√∂nnt ihr Euch einen TS-Typen und einen Hook erzeugen
* Die getypte Variante kennt dann auch alle Action-Typen, die per installierter Middleware (z.B. Thunk) erlaubt sind
* ```typescript
type AppDispatch = typeof store.dispatch;

export const useAppDispatch: () => AppDispatch = useDispatch;
```
* Anstatt der `useDispatch`-Funktion verwendet ihr in Eurer Anwendung dann einfach `useAppDispatch`

---
### √úbung: Redux Toolkit

* _Verwende f√ºr die Inhalte der PostEditor-Komponente einen RTK Slice_
* Daf√ºr arbeiten wir im Workspace `blog-example/workspace-redux`. 
* Bitte bestehenden `npm start`-Prozess beenden und in `workspace-redux` erneut ausf√ºhren
* Todos findest Du in der Datei `redux/editor-slice.ts`
* Der Store ist schon fertig konfiguriert, Du musst "nur" den Slice bauen und den `PostEditor` anpassen
* M√∂gliche L√∂sung: `steps/70-redux/72-rtk-create-slice`
* Wenn Du fertig bist, bitte die Hand in Teams heben üôã

---
<!-- .slide: id="t-redux-thunk" -->
### Redux
## Komplexe Actions

* Problem 1: **Asynchroner Code** (z.B. beim Laden von Daten), Arbeiten mit Promises
* Wo unterbringen?
* **Reducer** m√ºssen Seiteneffekt-frei sein!
* **Actions** sind reine JavaScript-Objekte ohne Methoden/Logik!
* Problem 2: Weiteres Problem: fachliche Abl√§ufe oft komplex(er) als nur eine Action.
* Zum Beispiel Lifecycle eines Server-Requests: Typisch: Request Start, Request l√§uft, Request erfolgreich/Request fehlgeschlagen
* In solchen F√§llen werden √ºblicherweise [Thunk Actions](https://github.com/reduxjs/redux-thunk) verwendet
* Alternativen: Redux Saga oder Redux Observable
---
### Thunk Actions 

* <!-- .element: class="demo" --> Laden der Posts mit normaler Thunk Action
* <!-- .element: class="demo" --> Laden der Posts mit createAsyncThunk
                
  </textarea
          >
        </section>

        <section>
          <h3>Hintergrund: Redux Middleware</h3>
          <ul>
            <li>
              Eine Middleware-Funktion bekommt alle dispatchen Actions √ºbergeben, bevor sie in den
              Store gelangen
            </li>
            <li>
              Die Middleware kann die Action annehmen, ver√§ndern, ablehnen und/oder weiterleiten
            </li>
            <li>Typische Anwendungsf√§lle: Logging, asynchrone Verarbeitung</li>
            <li>Die Middleware-Funktionen werden bei der Konfiguration des Stores angegeben</li>
            <li>In der Regel schreibst Du keine Middlewares selbst, sondern verwendest fertige</li>
          </ul>
        </section>

        <section data-markdown>
          <textarea data-template>
### Thunk Action

- Als `Thunk Action` wird eine Action bezeichnet, die selbst eine Funktion (!) ist
- Ein Action-Creator kann eine Thunk Action, also eine Funktion zur√ºckliefern.
- Diese Funktion wird von der Thunk Middleware aufgerufen
- Der Thunk-Funktion werden zwei Parameter √ºbergeben:
- Die `dispatch`-Funktion. Damit kann sie beliebig viele Actions ausl√∂sen
- Die `getState`-Funktion, mit der sie (lesenden) Zugriff auf den State hat
- Die Thunk-Funktion darf asynchron sein!  
  </textarea
          >
        </section>

        <section>
          <h3>Asynchrone Actions mit Thunk Middleware</h3>
          <p>
            Schritt 1: <b>Dispatchen von Actions</b>: Komponente bleibt unver√§ndert, dispatched
            weiterhin eine Action, die wie eine "normale" Redux Action aussieht
          </p>
          <div>
            <pre><code>
import { loadPosts } from "./posts-slice";

function App() {
React.useEffect( 
  () => dispatch(loadPosts()),
  []
);

return ...;
}
</code></pre>
          </div>
        </section>

        <section>
          <h3>Asynchrone Actions mit Thunk Middleware</h3>
          <p>
            Schritt 2: <b>Action Creator</b>: Hier k√∂nnen jetzt weitere Actions, auch asynchron,
            dispatched werden
          </p>
          <pre><code>
    // 'loadPosts' ist ein Action-Creator, der eine Thunk-Action zur√ºckliefert!
    export function loadPostsWithCache() {
      //              v--- Thunk-Action!
      return (dispatch, getState) => {
        dispatch(loadPostRequestStarted()); 
        try {
          posts = await loadPostsWithFetch();
          dispatch(loadPostRequestFinished(posts));
        } catch (err) {
          dispatch(loadPostRequestFailed(err));
        }
      }
    }  
</code></pre>
        </section>

        <section data-markdown>
          <textarea data-template>
### Asynchrone Actions

* In einer Thunk-Action k√∂nnt ihr auf den State _lesend_ zugreifen (`getState`-Parameter)
* Ihr k√∂nnt den State aber _nicht ver√§ndern_!
* In den Thunk-Actions k√∂nnt ihr beliebig viele weitere (Thunk-) Actions dispatchen
* Ihr k√∂nnt also z.B. "normale" Actions dispatchen, dei dann von "normalen" Reducern verarbeitet werden
* Im gezeigten Beispiel sind dass die "Lifecycle-Actions" (`loadPostRequestStarted` etc.)
</textarea
          >
        </section>

        <section>
          <h2>Redux Thunk</h2>
          <p>Thunk Actions k√∂nnen nicht nur f√ºr asynchone Anwendungsf√§lle verwendet werden</p>
          <ul>
            <li>
              F√ºr Anwendungsf√§lle in den allgemein mehr als eine Action dispatched werden soll
            </li>
            <li>
              Es ist darin erlaubt, beliebige Seiteneffkte auszuf√ºhren, z.B. eine uuid generieren
              oder auf die Uhrzeit zuzugreifen
            </li>
            <li>
              Im Gegensatz zum Reducer hat ein Action-Creator Zugriff auf den gesamten State und
              kann z.B. eine Cache-Funktionali√§t implementieren
            </li>
            <li>
              <pre><code class="typescript line-numbers"  >
export function loadPostsWithCache() {

return (dispatch, getState) => {

  if (getState().posts.posts) {
    // Posts sind schon geladen => nicht erneut laden
    return;
  }


  dispatch(postsLoading());

  // ...wie gesehen: Posts laden etc.
};
}    </code></pre>
            </li>
          </ul>
          <!-- <p>
<strong
  >Action-Creators sind die einzigen Teile einer Redux-Anwendung, die asynchrone
  Operationen ausf√ºhren d√ºrfen</strong
>
</p> -->
        </section>
        <!-- ============================================================================= -->

        <section data-markdown>
          <textarea data-template>
### Redux Thunk in Redux Toolkit
* Die Redux Thunk Middleware ist in Redux Toolkit integriert
* (Asynchrone) Thunk Action Creator k√∂nnen aber nicht im `reducers`-Objekt eines Slices definiert werden
* Ihr m√ºsst sie als "normale" Funktion au√üerhalb von <code>createSlice</code> hinschreiben (wie im Beispiel gesehen)
* Aber nat√ºrlich k√∂nnt ihr in dem Thunk Action Creator die Actions aus Euren Slices dispatchen:
* ```typescript
type LoadPostRequestFinished = { loadedPosts: BlogPost[] };

const postsSlice = createSlice({
reducers: {
loadPostRequestStarted(state) {
  state.loading = true;
}
loadPostRequestFinished(state, action: PayloadAction<LoadPostRequestFinished>) {
  state.loading = false;
  state.posts = action.payload.loadedPosts;
}
}
});

// Thunk Action Creator
export function loadPosts() { 

return async (dispatch, getState) => {
dispatch(postsSlice.action.loadPostRequestStarted());
const posts = ...;
dispatch(postsSlice.action.loadPostRequestFinished({loadedPosts: posts }));
}
}
```
---
### createAsyncThunk: Automatische Lifecycle-Actions
* In der asynchronen Verarbeitung soll h√§ufig eine Art Lifecycle ausgedr√ºckt werden (z.B. "loading", "finished", "failed")
* Mit [createAsyncThunk](https://redux-toolkit.js.org/api/createAsyncThunk) kannst Du vereinfacht Thunk-Actions schreiben, die solche Actions
automatisch dispatchen
* Du musst dann nur noch die fachliche Logik implementieren (z.B. das Laden der Daten)
* Deine Thunk Action liefert ein Promise zur√ºck.
* Vom Zustand des Promises macht RTK dann abh√§ngig, welche Lifecycle-Action dispatched wird:
* `pending` (Promise wird gerade verarbeitet, z.B.: Server-Call l√§uft)
* `fulfilled` (Promise wurde erfolgreich aufgel√∂st/resolved, Daten sind geladen worden)
* `rejected` (Beim Verarbeiten des Promises ist ein Fehler aufgetreten)
---
### createAsyncThunk: API

* Die `createAsyncThunk`-Funktion erwartet zwei Parameter:
* Den Action `type` als String (z.B. `"posts/load"`)
* Eine Callback-Funktion (`payloadCreator`), in der die Action-Logik (z.B. das Laden von Daten) implementiert ist
* ```typescript
export const loadPosts = createAsyncThunk("posts/load", async () => {
const response = await fetch("http://localhost:7000/posts?slow");
const json = (await response.json()) as BlogPost[];
return json;
});
```
*  Diese `loadPosts`-Action kann wie gewohnt dispatched werden:
* ```typescript
dispatch(loadPosts());
```
* Es werden dann drei Actions dispatched:
* `posts/load/pending` und dann:
* `posts/load/fulfilled` oder `posts/load/rejected`
* Die `posts/load/fulfilled`-Action enth√§lt au√üerdem den ermittelten Wert des Promises

---
### createAsyncThunk: Verarbeiten der Actions

* Der R√ºckgabe-Wert der Thunk-Action wird als `payload` an die `fulfilled`-Action geh√§ngt
* Wenn die Thunk-Action fehlschl√§gt, wird der Fehler der Payload als `error` √ºbergeben
* Die ausgel√∂sten "Lifecycle"-Actions kannst Du mit einem `extraReducer` am Slice verarbeiten
* Damit kannst du zum Beispiel den aktuellen Lifecycle in den State h√§ngen
* Oder die geladenen Daten bzw. den aufgetretenen Fehler
* Um die Actions auszuw√§hlen kannst du die `addCase`-Funktion von `extraReducers` verwenden
* F√ºr die drei Lifecycle Status gibt es jeweils ein Attribute an der Action, das Du √ºbergeben kannst:
* ```typescript
const loadPosts = createAsyncThunk(...);

const postsSlice = createSlice({
initialState: { loading: false, posts: [] },

extraReducers: builder => {

builder.addCase(loadPosts.pending, (state) => { 
state.loading = true;
})

builder.addCase(loadPosts.fulfilled, (state, action) => { 
state.loading = false;
state.posts = action.payload;
});

builder.addCase(loadPosts.rejected, (state, action) => {
state.loading = false;
state.error = action.error;
});
}
})
```


---
###  createAsyncThunk: API Details

* Die [`payloadCreator`-Callback-Funktion](https://redux-toolkit.js.org/api/createAsyncThunk#payloadcreator) von `createAsyncThunk` kann zwei Parameter annehmen:
1. Parameter: Objekt, mit dem Du Argumente beim dispatchen √ºbergeben kannst (z.B. Id der zu lesenden Daten)
2. `thunkAPI`-Objekt. Dieses Objekt enth√§lt unter anderem die `dispatch` und die `getState`-Funktion, um weitere Actions zu dispatchen oder auf den State lesend zuzugreifen. Mit `rejectWithValue` kann ein angepasster `error` zur√ºckgeliefert werden
* ```typescript
export const loadPostById = createAsyncThunk("posts/loadById", async (postId: string, thunkApi) => {

// Beispiel: Zugriff auf State
const post = getState().posts.find(p => p.id === postId);
if (post) {

// Beispiel: Dispatch weiterer Actions
thunkApi.dispatch(metricSlice.actions.cacheHit(postId));
return post;
}
thunkApi.dispatch(metricSlice.actions.cacheMiss(postId));

const response = await fetch(`http://localhost:7000/posts/${postId}`);

if (response.status === 404) {

// Beispiel: Eigenes Fehler-Objekt
return thunkApi.rejectWithValue({errorMessage: "Blog Post not found"});
}

return response.json();
});
```
* ```typescript
dispatch(loadPostById(123))
```


---
### √úbung: Thunk Actions

* _Baue eine Thunk Action zum Laden der Post-Liste_

* Die Post-Liste wird in `PostListPage` mit `fetch` geladen. Das soll nun √ºber Redux passieren.
* Baue eine Thunk-Action in `redux/posts-slice-thunk.ts` zum Laden der Post
* Verwende die Action und den globalen State dann in `PostListPage` 
* TODOs siehe `posts-slice-thunk.ts`
* M√∂gliche L√∂sung: `steps/70-redux/74-rtk-thunk-actions`
* Dateien: `posts-slice-thunk.ts` und  `PostListPage.tsx`
* Wenn Du fertig bist, bitte die Hand in Teams heben üôã


---
## Redux Toolkit Query
<!-- .slide: id="t-rtk-query" -->


---
### Redux Toolkit Query

* Die [RTK Query](https://redux-toolkit.js.org/rtk-query/overview) API ist der "offizielle" Weg des Redux Toolkits, um mit Daten vom Server zu arbeiten
* Aus dem [Redux Styleguide](https://redux.js.org/style-guide/#use-rtk-query-for-data-fetching): _we recommend using RTK Query as the default approach for data fetching and caching in a Redux app. We recommend against writing data fetching logic by hand in almost all cases._
* RTK Query unterst√ºtzt Lesen und Schreiben von Daten (per HTTP), Caching und Lifecycle

---
### Redux Toolkit Query

* Mit `createApi` wird eine Art API-Slice definiert (√§hnlich wie `createSlice` aber f√ºr API-Endpunkte)
* Damit wird beschrieben, welche Endpunkte es gibt, und wie auf diese Zugegriffen werden soll
* Auch die Konfiguration des Caches erfolgt dar√ºber
* F√ºr alle konfigurierten Endpunkte werden React Hooks generiert, mit denen die Server-Requests ausgef√ºhrt werden k√∂nnen
* ```typescript
import { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";

export const postsApi = createApi({
baseQuery: fetchBaseQuery({ baseUrl: "http://localhost:7000" }),

endpoints: builder => ({
loadPosts: builder.query<BlogPost[], void>({
query: () => "/posts",
}),

getPost: builder.query<BlogPost, string>({
query: postId => `/posts/${postId}`,
}
})
})
});

export const { useLoadPostsQuery, useGetPostQuery } = postsApi;

```
---
### createApi

* An [createApi](https://redux-toolkit.js.org/rtk-query/api/createApi) wird eine Objekt mit der Konfiguration deiner Endpunkte √ºbergeben.
* Du musst darin zwei Dinge zwingend angeben:
* Den `baseQuery`. Eine Funktion, die bestimmt, wie Server Requests technisch durchgef√ºhrt werden sollen. 
* F√ºr viele F√§lle ist die [`fetchBaseQuery`](https://redux-toolkit.js.org/rtk-query/api/fetchBaseQuery)-Funktion aus dem RTK ausreichend. Dieser √ºbergibst Du eine `baseUrl` und die Requests werden dann mit der `fetch` API durchgef√ºhrt.
* `endpoints` Eine Callback-Funktion, mit der Du deine Endpunkt-Konfiguration festlegen kannst.

---
### Endpunkte

* Die Endpunkte deiner API werden mit der `endpoints`-Callback-Funktion festgelegt.
* Diese Funktion erh√§lt ein `builder`-Objekt, mit Du mit der `query`- und `mutation`-Funktion Endpunkte definieren kannst
* Die `query`-Endpunkte sind zum lesen von Daten
* Die `mutation`-Endpunkte sind f√ºr alle Arten von ver√§ndernden Server-Zugriffen (z.B. HTTP POST oder HTTP PUT)
* Die `endpoints`-Funktion liefert ein Objekt zur√ºck, in dem die **Keys** (fachliche) Namen von Endpunkten sind. 
* Die Namen bestimmen unter anderem die generierten Hook-Funktion zum Aufrufen der Endpunkte
* Der **Wert** ist jeweils ein konfigurierter Endpunkt, der mit dem `builder` erzeugt wurde. 
* Das folgende Beispiel zeigt zwei Query-Endpunkte mit den Namen `loadPosts` bzw. `getPost`  
* ```typescript
export const postsApi = createApi({
endpoints: builder => return {
loadPosts: builder.query<BlogPost[], void>({
  query: () => "/posts"
}),

getPost: builder.query<BlogPost, string>({
  query: postId => `/posts/${postId}`
})
}
});

```
---
### Queries an Endpunkten definieren
* Mit der `query`-Funktion kann ein Query-Endpunkt (in der Regel HTTP GET) definiert werden
* Die Funktion erwartet zwei _Typ-Argumente_ f√ºr TypeScript und einen _Parameter_:
* Die _Typ-Argumente_ geben an:
1. den R√ºckgabe-Typ der Daten, die √ºber den Endpunkt gelesen werden
2. Ein Typ, der erforderliche Parameter f√ºr den Endpunkt beschreibt (oder `void` f√ºr keinen Parameter)
* ```typescript
// Liefert BlogPost[] zur√ºck, erwartet keine Parameter
builder.query<BlogPost[], void>(...);

// Lierfert BlogPost zur√ºck, erwartet einen Parameter vom Typ string
builder.query<BlogPost, string>(...);
```
* Mit dem _Parameter_ √ºbergibst du ein Objekt mit der eigentlichen Konfiguration f√ºr diesen Endpunkt
* Du musst mindestens die `query`-Funktion angeben, die den Pfad/URL des Endpunktes zur√ºckliefert

---
### Endpunkt-Konfiguration

* Die `query`-Callback-Funktion nimmt einen Parameter entgegen
* Der Typ des Paramters wird `builder.query` √ºbergeben.
* Den Wert f√ºr diesen Parameter muss der Aufrufer beim Ausf√ºhren des Queries √ºbergeben
* _Ohne_ Parameter:
* ```typescript
builder.query<BlogPost[], void>({ query: () => `/api/posts ` });
```
* _Mit_ Parameter (Beispiel: Objekt mit `postId` und `commentId`):
* ```typescript
builder.query<Comment, {postId: string, commentId: string}>({
query: ({postId, commentId}) => `/api/posts/${postId}/comments/${commentId`
})
```
* Bei diesem Endpunkt m√ºsste der Aufrufer ein Objekt mit `postId` und `commentId` √ºbergeben (dazu sp√§ter mehr)
* Es gibt noch eine ganze Reihe weiterer Konfigurationsm√∂glichkeiten f√ºr einen Endpunkt, siehe dazu die ausf√ºhrliche Dokumentation

---
### Ausf√ºhren von Queries

* F√ºr jeden Endpunkt werden [React Hooks](https://redux-toolkit.js.org/rtk-query/api/created-api/hooks#hooks-overview) generiert, die Du verwenden kannst, um den Endpunkt aufzurufen und die Daten abzufragen.
* Wir betrachten den [`useQuery`](https://redux-toolkit.js.org/rtk-query/api/created-api/hooks#usequery) Hook
* Der Name ist `useEndpunktNameQuery` (also zum Beispiel `useGetPostQuery`)
* Die generierten Hooks stehen √ºber das API-Objekt (R√ºckgabe von `createApi`) zur Verf√ºgung:
* ```typescript
export const postsApi = createApi({
// ...
endpoints: builder => ({

  loadPosts: builder.query<BlogPost[], void>({ ... })

  getPost: builder.query<BlogPost, string>({ ... })
})
});

export const { useLoadPostsQuery, useGetPostQuery } = postsApi;
```
---
### Ausf√ºhren von Queries mit dem useQuery-Hook

* Den generierten Hook kannst Du in deiner Komponente verwenden
* Der Query wird unmittelbar beim Rendern der Komponente ausgef√ºhrt
* Sind die Daten f√ºr den Enpunkt (noch) im Cache vorhanden, werden die Daten stattdessen aus dem Cache zur√ºckgegeben
* Auch wenn die geladenen Daten automatisch im "normalen" Redux Store abgelegt werden, greift man immer √ºber die Query-Hooks darauf zu
(nie √ºber `useSelector`)
* Der Hook liefert ein `UseQueryResult`-Objekt zur√ºck, das Informationen √ºber den Query-Status und die Daten gibt.
* ```typescript
function PostListPage() {
const loadPostsQueryResult = useLoadPostsQuery();

if (loadPostsQueryResult.isLoading) {
return <LoadingIndicator>Server Request running. Please wait.</LoadingIndicator>;
}

if (loadPostsQueryResult.isError) {
return <h1>Error while fetching data!</h1>;
}

return <PostList posts={loadPostsQueryResult.data} />;
}
```

---
### Das Query-Ergebnis
* Der `useQuery`-Hook liefert unmittelbar ein Result-Objekt zur√ºck und f√ºhrt dann den Query aus
* √úber das Result-Objekt kannst Du Status des Requests und ggf. Daten bzw. Fehler abfragen
* Sobald sich der Status √§ndert (zum Beispiel Request ist zur√ºckgekehrt), wird die Komponente neu gerendert und der Hook gibt ein neues Result-Objekt zur√ºck
* Bestandteil des Result-Objektes:
* `isUninitialized`: Request wurde noch nicht gestartet
* `isLoading`: Request l√§uft gerade
* `isError`: `true` wenn beim Lesen der Daten ein Fehler aufgetreten ist
* `data`: Die geladenen Daten (nur wenn `isLoading` und `isError` `false` sind)
* `error`: Beim Laden aufgetretener Fehler (nur wenn `isError` `true` ist)

---
### Parameter √ºbergeben
* Sofern Du in der Endpunkt-Konfiguration angegeben hast, dass der Endpunkt Parameter braucht, musst Du diese bei dem Hook angeben:
* Beispiel: ein Endpunkt mit zwei Parametern
* ```typescript
// 
type GetCommentParams = { postId: string; commentId: string }

export const postsApi = createApi({
// ...
endpoints: builder => ({

getComment: builder.query<BlogPost, GetCommentParams>({
  query: params => `/posts/${params.postId}/comments/${params.commentId}`,
})

})
});
export const { useGetCommentQuery } = postsApi;
```
* Verwendung des Hooks:  
* ```typescript
function CommentPage() {
const result = useGetCommentQuery({postId: "P1", commentId: "C1"});

// result wie gesehen
}  
```

---
### Ausf√ºhren des Queries unterbinden

* Der `useQuery` f√ºhrt den Query unmittelbar beim Rendern der Komponente aus
* Das will man aber nicht immer. 
* Um die Ausf√ºhrung zu unterbinden, kannst Du das `skipToken` oder die `skip`-Option verwenden. 
* Die `skip`-Option kann als zweiter Parameter √ºbergeben werden:
* ```typescript
type PostPageProps = { postId: string, loadPost: boolean }

function PostPage({ postId, loadPost }: PostPageProps) {

const r = useGetPostQuery(postId, { skip: !loadPost });

}
```
* Das `skipToken` ist ein Objekt, dass von RTK Query bereitsgestellt wird, und das (statt Query-Parameter) als erster Parameter √ºbergeben werden kann:
* ```typescript
import { skipToken } from '@reduxjs/toolkit/query/react'

function PostListPage() {
const r = useLoadPostsQuery(skipToken);
}
```
---
### Das skipToken  
* Das `skipToken` musst Du verwenden, wenn dein Query _keine_ Parameter hat, _oder_ Du die erforderlichen Parameter nicht zur Verf√ºgung hast
* Beispiel: die folgende Komponente erwartet _optional_ eine postId als Property. F√ºr den Query ist die `postId` aber Pflicht.
* ```typescript
type PostPageProps = { postId?: string | null}

function PostPage({postId}: PostPageProps) {

const r = useGetPostQuery(postId); // Compile-Error, weil postId undefined oder null sein kann

}
```
* In diesem Fall kannst Du statt des Query-Parameters (`postId`) das `skipToken` √ºbergeben, wenn die `postId` nicht gesetzt ist:
* ```typescript
import { skipToken } from '@reduxjs/toolkit/query/react'

type PostPageProps = { postId?: string | null}

function PostPage({postId}: PostPageProps) {

const r = useGetPostQuery(postId ?? skipToken); // OK: Entwender postId oder - falls null - das skipToken

}
```
---
### √úbung: Daten laden mit RTK Query

* _Verwende RTK Query um die Daten f√ºr die Post-Liste und die Einzeldarstellung zu laden_

* In der `PostListPage` und der `PostPage` werden die Posts vom Server geladen
* Baue in `redux/posts-slice-thunk.ts` zwei Endpunkte f√ºr `/posts` und `/posts/{postId}`
* Dort findest Du weitere TODOs und Hinweise
* Bitte nur √úbung 1 ("Queries") machen (_nicht_ die Mutation-√úbung)
* Ersetze in `PostListPage` und`PostPage` den Code dort durch die `useQuery`-Hooks der beiden Endpunkte
* Wenn Du dann in der Anwendung navigierst, sollte ein BlogPost in der Einzeldarstellung nur _einmal_ geladen werden.
* Rufst Du ihn nocheinmal auf (Home -> P1 -> Home -> P1), sollte er beim zweiten Mal aus dem Cache kommen.
* In dem Workspace sind f√ºr die Arbeit mit den Post-Daten zwei Slices konfiguriert (`post-slice-thunk` und `post-slice-api`)
* Das ist hier nur zu Demo-Zwecken. In einer "richtigen" Anwendung w√ºrdest Du f√ºr _eine_ "Fachlichkeit" auch nur _einen_ Slice verwenden
* TODOs siehe `redux/posts-slice-api.ts`
* M√∂gliche L√∂sung: `steps/70-redux/76-rtk-query`
* Dateien: `posts-slice-api.ts`, `PostListPage.tsx`, `PostPage.tsx`
* Wenn Du fertig bist, bitte die Hand in Teams heben üôã

---
### RTK Query: Mutations und Cache

---
### Mutations

* **Mutations** sind Operationen, die Daten auf dem Server _ver√§ndern_
* Im Gegensatz dazu, sind Queries nur f√ºr _lesende_ Abfragen gedacht
* Mutations und Queries sind in RTK Query sehr √§hnlich, es gibt aber unterschiede:
* Bei Mutations wird h√§ufig ein Request Payload √ºbergeben (bei Queries nicht m√∂glich)  
* Es werden unterschiedliche HTTP Verben (POST/PUT/PATCH/DELETE) verwendet
* Die Mutations werden nicht beim Rendern der Komponente ausgef√ºhrt, sondern z.B. nach einer Benutzerinteraktion
* Da Mutations Daten ver√§ndern, kann es sein, dass danach Daten im lokalen Cache veraltet sind

---
### Defintion der Endpunkte
* Die Definition der Mutations erfolgt ebenfalls √ºber den `builder`, mit dem das `endpoint`-Objekt beschrieben wird.
* Die zugeh√∂rige Methode am `builder` hei√üt in diesem Fall `mutation` (nicht `query`)
* √úblicherweise ist das `query`-Objekt, das dem `builder` √ºbergeben wird, hier eine Funktion, die ein Objekt zur√ºckgibt
* Das Objekt beschreibt dann nicht nur den Pfad, sondern auch den Payload und HTTP Header.
* ```typescript
export const postsApi = createApi({
// ...
endpoints: builder => ({

// Query (GET)-Endpunkt:
loadPosts: builder.query<BlogPost[], void>({
  query: () => "/posts?slow",
}),

// Mutation (POST)-Endpunkt:
savePost: builder.mutation<BlogPost, NewBlogPost>({
  query: newPost => ({
    url: `posts`,
    method: "POST",
    body: newPost
  })
})
})
});

export const { useLoadPostsQuery, useSavePostMutation } = postsApi;

```
---
### Mutations ausf√ºhren

* Auch f√ºr jede Mutation wird ein React Hook generiert.
* Dieser [`useMutation`-Hook](https://redux-toolkit.js.org/rtk-query/api/created-api/hooks#usemutation) hat das Namenspattern `useEndpunktNameMutation`
* Im Gegensatz zu `useQuery` wird die Mutation nicht beim Rendern ausgef√ºhrt.
* Stattdessen liefert der Hook nicht nur das Result-Objekt zur√ºck, sondern auch eine `trigger`-Funktion zum Ausf√ºhren der Mutation
* √Ñhnlich wie bei Reacts `useState` ist der R√ºckgabe-Typ ein Tuple mit der `trigger`-Funktion und dem Result-Objekt:
* ```typescript
const [savePost, savePostResult] = useSavePostMutation();

function onSavePostClick(newPost: NewBlogPost) {
savePost(newPost);
}

if (savePost.isLoading) {
return <div>Saving new post...</div>
}

if (savePost.isError) {
return <div>Saving Post failed...</div>
}

if (savePost.isSuccess) {
return <div>Saving Post succeeded!</div>
}

return ...;

```
---
### Der RTK Query Cache

* Alle gelesenen Daten werden im Store abgelegt und dort gechached
* Wie lange sie darin liegen, h√§ngt unter anderem davon ab, ob noch eine Komponente auf die Daten zugreift
* Grunds√§tzlich ist das pro Endpunkt einstellbar
* In einer Mutation kannst Du auch explizit festlegen, welche Daten von dieser ge√§ndert werden
* Die Daten werden im Cache dann als "veraltet" markiert und in jedem Fall beim n√§chsten Query neu gelesen
* Dazu kennt RTK Query das Konzept von **Tags**

---
### Tags

* Jeder Query-Endpunkt kann mit einem oder mehreren Tags assoziiert werden.
* √úber die Tags kann eine Mutation ausdr√ºcken, welche Daten von ihr ver√§ndert bzw. nach der Ausf√ºhrung nicht mehr g√ºltig sind.
* Angabe der Tags:
* Mit `tagTypes` wird beim Erzeugen der API (`createApi`) angegeben, welche "Typen" von Tags es √ºberhaupt gibt, z.B. `Post` oder `User`
* Angegeben werden die konkreten Tags dann mit der `provideTags`-Eigenschaft bei der Konfiguration des Endpunkts
* ```typescript
export const postsApi = createApi({
tagTypes: ["BlogPost"],

endpoints: builder => ({
loadPosts: builder.query<BlogPost[], void>({
query: () => "/posts?slow",
providesTags: ["BlogPost"]
}),

getPost: builder.query<BlogPost, string>({
query: postId => `/posts/${postId}/?slow`,
providesTags: (_result, _error, postId) => {
  return [{ type: "BlogPost", id: postId }, "BlogPost"];
}
})
})
});

```
<!-- .element: class="todo" -->ist das Beispiel richtig, oder muss getPost auch 'Post' haben?  
---
### Tags

* Ein Tag kann entweder nur ein String sein (`BlogPost`, `User`) oder ein Objekt, bestehend aus `type` und `id`
* Mit der Id kann ein Tag genauer beschrieben werden:
* _Ohne_ Id: dieser Endpunkt stellt allgemein "irgendwelche" Daten dieses Typs zur Verf√ºgung
* _Mit_ Id: dieser Endpunkt stellt genau diese Daten ("Instanzen") zur Verf√ºgung
* `provideTags` kann entweder ein Array mit Tags sein oder ein Callback-Funktion
* Die Callback-Funktion wird von RTK Query aufgerufen mit dem Query-Ergebnis (oder Fehler) und den √ºbergebenen Parametern
* Auf dieser Basis kann die Funktion dann eine Liste von Tags f√ºr das konkrete Ergebnis zur√ºckliefern.
* Im folgenden Beispiel ist die postId nicht vor der Ausf√ºhrung des Queries bekannt.
* Der Cache Tag kann also erst auf Basis der geladenen Daten ermittelt werden:
* ```typescript
export const postsApi = createApi({
tagTypes: ["BlogPost"],

endpoints: builder => ({
  getNewestPost: builder.query<BlogPost, string>({
    query: postId => `/posts?orderBy=date&limit=1`,
    providesTags: (result) => {
      return result ? [{ type: "BlogPost", id: result.postId }] : [ "BlogPost" ]
    }
  })
})
});
```
---
### Tags invalidieren
* Eine Mutation kann angeben, welche Tags nach ihrer Ausf√ºhrung ung√ºltig sind
* Dazu wird die `invalidatesTags`-Eigenschaft bei der Defintion des Mutation-Endpunkts verwendet.
* Die Mutation kann ein einzelnes Tags oder eine Liste von Tags invalidieren
* Wie bei `provideTags` kann die `invalidatesTags`-Eigenschaft eine Liste oder eine Funktion zur√ºckliefern. 
* Der Funktion werden dieselben Argumente √ºbergeben wie `provideTags`
* ```typescript
export const postsApi = createApi({
tagTypes: ["BlogPost"],


endpoints: builder => ({
savePost: builder.mutation<BlogPost, NewBlogPost>({
  query: newPost => ( ... ),
  invalidatesTags: ["BlogPost"]
}),

updatePost: builder.mutation<BlogPost, BlogPost>({
  query: post => ( ... ),
  invalidatesTags(result, error, param) { return [type: "BlogPost", id: param.id] }
})
})
});
```
---
### Tags invalidieren
* In diesem Beispiel soll ein einzelner Blog Post aktualisiert werden:
* ```typescript
export const postsApi = createApi({
tagTypes: ["BlogPost"],

loadPosts: builder.query<BlogPost[], void>({
query: () => "/posts",
providesTags: ["BlogPost"]
}),

endpoints: builder => ({
updatePost: builder.mutation<BlogPost, BlogPost>({
  query: post => ( ... ),
  invalidatesTags(result, error, param) { return [type: "BlogPost", id: param.id] }
})
})
});
```

* Die entsprechende Mutation markiert den Blog Post mit seinem Cache als veraltet
* Die Daten des `loadPosts` Endpunkts sind allerdings nur mit dem `BlogPost`-Tag assoziiert
* Das hei√üt die Daten, die `loadPosts` zur√ºckgeliefert hat, werden nicht als veraltet markiert. In dieser Liste k√∂nnte also der alte Blog Post weiterhin vorhanden sein.
---
### Tags invalidieren

* Um das Problem zu l√∂sen gibt es zwei M√∂glichkeiten
1. `updatePost` liefert auch den Tag `BlogPost` zur√ºck. Damit w√ºrde die Liste ung√ºltig
2. Die `loadPosts`-Daten werden auch mit einer `id` assoziiert
* In beiden F√§llen wird komplette Ergebnis von `loadPosts` als veraltet markiert und die erste Komponente, die `useLoadPostsQuery` verwendet, w√ºrde die Daten erneut laden.
* Beispiel: hier werden die Ids der Blog Posts, die `loadPosts` geladen hat, ebenfalls als Tag f√ºr `loadPosts` verwendet:
* ```typescript
export const postsApi = createApi({
tagTypes: ["BlogPost"],

loadPosts: builder.query<BlogPost[], void>({
query: () => "/posts",
providesTags(result) { return result.map(p => ({type: "BlogPost", id: p.id})).concat("BlogPost") }
}),

endpoints: builder => ({
updatePost: builder.mutation<BlogPost, BlogPost>({
  query: post => ( ... ),
  invalidatesTags(result, error, param) { return [type: "BlogPost", id: param.id] }
})
})
});
```
---
### √úbung: Mutations mit RTK Query

* _Baue eine Mutation zum Speichern eines neuen BlogPosts_
* In der `PostEditorPage` wird `fetch` zum Speichern des Blog Posts verwendet. 
* Erweitere in `redux/posts-slice-api` die `postsApi` um eine Mutation zum Speichern des Posts
* Weitere Informationen und Todos findest Du dort
* Ersetze den `fetch`-Code in `PostEditorPage` durch den `useSavePostMutation`-Hook
* Wenn das funktioniert, kannst Du noch _Cache Tags_ einf√ºhren, um den Cache nach dem Speichern eines Posts als "veraltet" zu markieren
* M√∂gliche L√∂sung: `steps/70-redux/78-rtk-query-mutation`
* Dateien: `posts-slice-api.ts`, `PostEditorPage.tsx`
* Wenn Du fertig bist, bitte die Hand in Teams heben üôã


* Liste wird nicht aktualisiert üò¢
* TagTypes hinzuf√ºgen `BlogPost`



                
  </textarea
          >
        </section>

        <!-- ============================================================================= -->
        <section>
          <h2>Geschafft! üòä</h2>
          <h3>Vielen Dank f√ºr Eure Teilnahme!</h3>
          <h3>Viel Spa√ü und Erfolg mit React!</h3>
          <p>Wenn ihr noch Fragen habt, k√∂nnt ihr mich erreichen:</p>
          <p>Mail: <a href="mailto:nils@nilshartmann.net">nils@nilshartmann.net</a></p>
          <p>
            Web: <a href="https://nilshartmann.net" target="_blank">https://nilshartmann.net</a>
          </p>
          <p>
            Twitter: <a href="https://twitter.com/nilshartmann" target="_blank">@nilshartmann</a>
          </p>
        </section>
      </div>
    </div>

    <script src="slides/revealjs/reveal.js/dist/reveal.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/notes/notes.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/markdown/markdown.js"></script>
    <script src="slides/revealjs/reveal.js/plugin/highlight/highlight.js"></script>
    <script src="slides/revealjs/config.js"></script>
  </body>
</html>
